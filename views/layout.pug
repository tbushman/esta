doctype strict
html
	head
		meta(charset="utf-8")
		meta(http-equiv="X-UA-Compatible", content="IE=edge; charset=utf-8")
		//- meta(name="google-site-verification", content="p4ANTDMaoAMsiWW5CwWtiY9v8mEPGv8KhQetzWrJlwc")
		title= appTitle
		meta(name="viewport", content="width=device-width, initial-scale=1.0")
		base(href="")
		link(href="/stylesheets/gpo.css")
		link(rel="stylesheet", href="/stylesheets/style.css")
		link(rel="stylesheet", href="/stylesheets/leaflet.css")
		link(rel="stylesheet", href="/stylesheets/leaflet.draw.css")
		script(type="text/javascript", src="/scripts/vue.js")
		script(type="text/javascript", src="/scripts/jquery.min.js")
		script(type="text/javascript", src="/scripts/jquery-ui.min.js")
		script(type="text/javascript", src="/scripts/moment-with-locales.min.js")
		script(type="text/javascript", src="/scripts/marked.min.js")
		script(type="text/javascript", src="/scripts/leaflet.js")
		script(type="text/javascript", src="/scripts/Path.Drag.js")
		script(type="text/javascript", src="/scripts/Leaflet.Editable.js")
		script(type='text/javascript', src='/scripts/leaflet-image_0_4_0.js')
		script(type="text/javascript", src="/scripts/jszip.min.js")
		script(type="text/javascript", src="/scripts/signaturePad.js")
		script(type="text/javascript", src="/scripts/htmldiff.js")
		script(type="text/javascript", src="https://cloud.tinymce.com/stable/tinymce.min.js?apiKey=yb2pwtctf7qznwdoo61w3kyj127j61gch5uhhzneop9mfkg7")
	body
		block page
		block header
		block content
		div#gpresult
		
		#map
		a#publish_logo(href="https://github.com/tbushman/esta" target="_blank")
			img(src="/images/publish_logo.svg")
		
		a#publish_logo.tb-font-xxxs(href="//bli.sh/pp/blish", target="_blank", style="top: calc(100vh - calc(var(--thumbw) * 1.35));right: 23px;margin:0;text-align:right;bottom: auto;") Privacy policy

		script(type="text/javascript").
			Vue.prototype.moment = moment;
			Vue.prototype.marked = marked;
			Vue.prototype.SignaturePad = SignaturePad;
			Vue.prototype.$ = $;
			Vue.prototype.htmldiff = htmldiff;
			new Vue({
				el: '#vue',
				data: function data(){
					return {
						lvl: 'h',
						h: 0,
						i: 0,
						j: 0,
						m: 0,
						signable: this.parseBool(!{JSON.stringify(signable)}),
						unsigned: this.parseBool(!{JSON.stringify(unsigned)}),
						avail: this.parseBool(!{JSON.stringify(avail)}),
						type: this.parseObj(!{JSON.stringify(type)}),
						pu: this.parsePu(!{JSON.stringify(pu)}),
						loggedin: (this.parseObj(!{JSON.stringify(session)}) !== '' && this.parseObj(!{JSON.stringify(session.loggedin)}) !== '' ? this.parseObj(!{JSON.stringify(session.loggedin)}) : null ),
						menu: this.parseObj(!{JSON.stringify(menu)}),
						dat: this.parseObj(!{JSON.stringify(dat)}),
						doc: this.parseObj(!{JSON.stringify(doc)}),
						layers: this.parseObj(!{JSON.stringify(layers)}),
						position: (!this.parseObj(!{JSON.stringify(session.position)}) ? {lat: 40, lng: -111.89, zoom: 6}/*null*/ : this.parseObj(!{JSON.stringify(session.position)})),
						edit: (this.parseObj(!{JSON.stringify(doc)}) === '' ? null : this.parseObj(!{JSON.stringify(doc)}).index),
						chindexes: [],
						chindex: 0,
						dindexes: [],
						dindex: (this.parseObj(!{JSON.stringify(doc)}) === '' ? 0 : this.parseObj(!{JSON.stringify(doc)}).index),
						cursor: null,
						input: '',
						fixedPug: '',
						map: '',
						mapActive: false,
						dataLayer: '',
						lMarker: '',
						thickness: 45,
						wWidth: window.innerWidth,
						wHeight: window.innerHeight,
						dPath: this.dPathAttr(),
						tinymce: null,
						dfi: 0,
						diff: null,
						web: true,
						export: this.parseBool(!{JSON.stringify(exports)}),
						ff: this.parseObj(!{JSON.stringify(ff)}),
						newDoc: {tempGeo:[]},
						placemenu: false,
						placetypes: [{
							name: 'Nation',
							url: '/json/us.json'
						},
						{
							name: 'State',
							url: '/json/usstates.json'
						}/*,
						{
							name: 'County',
							url: '/json/uscounties.json'
						}*/],
						modal: {msg:null},
						uploadisreplace: false,
						uploadchtitle: null,
						dragind: null,
						latlngs: null,
						gp: (this.parseObj(#{session.importgdrive}) !== '' ? this.parseObj(!{JSON.stringify(gp)}) : null),
						sliderIndex: 1,
						str: this.parseObj(!{JSON.stringify(str)}),
						ts: this.ifNullThenArr(!{JSON.stringify(ts)}),
						can: [],
						lyr: {},
						tis: [
							{
								ind: 0,
								name: 'in support of legislation',
								code: 'BILLS-',
								chapter: [
									{
										ind: 115,
										name: 'United States Congress',
										code: 'hres',
										section: [
											{
												ind: 108,
												name: 'House Simple Resolution (H. Res.)',
												code: 'ih'
											}
										]
									}
								]
							},
							{
								ind: 1,
								name: 'in Solidarity',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							},
							{
								ind: 2,
								name: 'Candidate for Public Office',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							},
							{
								ind: 3,
								name: 'Environmental Impact Statement',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							},
							{
								ind: 4,
								name: 'Geography',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							}
						],
						xml: this.parseObj(!{JSON.stringify(xml)}),
						accordions: (!this.parseObj(!{JSON.stringify(dat)}).length ? [[]] : Array(this.parseObj(!{JSON.stringify(dat)}).length).fill([]))
						
					}
				},
				components: {
					//- xmlStylesheet: {
					//- 	data(){
					//- 		return {
					//- 			url: '/stylesheets/billres.xsl'
					//- 		}
					//- 	},
					//- 	template: '<?xml-stylesheet type="text/xsl" :href="url"?>'
					//- },
					canvasc: {
						data: function() {
							return {
								signaturePad: null,
								ctx: null,
								dataUrl: null,
								pts: null,
								cW: window.innerWidth,
								cH: window.innerHeight,
								pu: this.$parent.pu
							}
						},
						mounted: function(){
							var self = this;
							self.signaturePad = new SignaturePad(self.$refs.canv, {
								onEnd: async function() {
									self.$refs.canv.style['letter-spacing'] = '0px'
									var ctx = self.$refs.canv.getContext('2d');
									ctx.font = '12px serif';
									
									var ts = '/'+self.pu.properties.givenName+'/'+moment().utc().format();
									ctx.beginPath();
									ctx.fillText(ts, 23, 132);
									ctx.closePath();
									self.dataUrl = self.signaturePad.toDataURL()
									self.pts = self.signaturePad.toData();
									self.$emit('update', self.dataUrl, ts, self.$refs.canv);
									
								},
								onBegin: function() {
									// clear timestamp only
									var ctx = self.$refs.canv.getContext('2d');
									ctx.clearRect(23, 123, 277, 32);

								}
							});
						},
						methods: {
							clearCanv(){
								var self = this;
								var ctx = self.$refs.canv.getContext('2d');
								ctx.clearRect(0, 0, 300, 150);
								
							}
						},
						template: 
						`
						<div class="row" style="text-align: center;">
						<canvas
							id="maincanvas"
							ref="canv"
						></canvas>
						<a role="button" @click="clearCanv" title="Clear signature" v-text="'Clear signature'"></a>
						</div>
						`
					}
				},
				updated: function(){
					var self = this;
					//- if (self.dindexes.length === 0) {
					//- 	self.dindexes = (self.dat && self.dat !== '' ? self.dat.map(function(data){
					//- 		return data.map(function(doc){
					//- 			return doc.index;
					//- 
					//- 		})
					//- 	}) : [[(!self.doc || self.doc === '' ? 0 : self.doc.index)]] );
					//- 	self.dindexes.sort();
					//- 
					//- }
				},
				mounted: function(){
					$(document).ready(function(){
						document.addEventListener('keydown', function(event) {
						  var keyName = event.key;
							if (keyName === 'Enter') event.preventDefault()
						});
					})
					var self = this;
					$(document).on('click', '.href', function(e){
						e.stopPropagation();
					});
					self.dindexes = (self.dat && self.dat !== '' ? self.dat.map(function(data){
						return data.map(function(doc){return doc.index});
					}) : [(!self.doc || self.doc === '' ? 0 : self.doc.index)] );
					self.dindexes.sort();
					$('.drop').slideToggle(100);
					$('.slidedown').slideToggle(100);
					$('.mainmenu').on('click', function(){
						if ($('.dropdown').hasClass('active')) {
							$('.dropdown').removeClass('active');
						} else {
							$('.dropdown').addClass('active');
						}
						$('.drop').slideToggle(100);
					});
					$('.submenu.drop').on('click', function(){
						if (!$(this).next('.slidedown')) {
							
							return;
						} else {
							
							$('.submenu.drop').not($(this)).removeClass('active');
							$(this).next('.slidedown').slideToggle(100);
							$(this).toggleClass('active');
							if (!$('.submenu.drop').not($(this)).next('.slidedown a').attr('href')) {
								$('.submenu.drop').not($(this)).next('.slidedown').slideUp(100);
							} else {
								
								$(this).parent('.slidedown').slideUp(100);
								if (!$(this).attr('href')) {
									$(this).children('.ui').children('i').toggleClass('fa-angle-right');
									$(this).children('.ui').children('i').toggleClass('fa-angle-down');
								} else {
									$('.dropdown').not($('.static')).slideUp(100);
								}
								//
							}
						}
					});
					var modal = document.getElementById('modal');
					if (self.type === 'geo') {
						var pos = null;
						if (navigator.geolocation) {
							var options = {
								enableHighAccuracy: true,
								timeout: 5000,
								maximumAge: 0
							};
							navigator.geolocation.getCurrentPosition(function(position) {
								pos = {
									lat: position.coords.latitude,
									lng: position.coords.longitude
								};
								console.log(pos)
								self.handleLocationOutcome(true, pos);
							}, function() {
								self.handleLocationOutcome(false, pos);
							}, options);
						} else {
							// Browser doesn't support Geolocation
							self.handleLocationOutcome(false, pos);
						}
					
					}
					self.accordions = (!self.doc || self.doc === '' ? 
						(!self.dat || self.dat === '' ? [[]] 
							: 
							self.dat.map(function(data){
								return []
							}) 
						)
						: 
						(
							self.dat && self.dat !== '' ?
							self.dat.map(function(data){return data.map(function(doc){return doc.index})})
							:
							[[self.doc.index]]
						)
					)
						if (!self.doc || self.doc === '') {
						} else {
							
							self.edit = self.doc.index;
							self.dindex = 0;
							console.log(self.pu, self.ts.length, !self.unsigned)
							
						}
						//- if (self.doc.properties.xmlurl && self.doc.properties.xmlurl !== '') {
						//- 	//- var url = 
						//- 	//- $.get(self.doc.properties.xmlurl +'?api_key='+ '#{session.gpo}' )
						//- 	//- .then(function(result){
						//- 	//- 	console.log(result);
						//- 		//- self.xml = self.doc.properties.xmlurl +'?api_key='+ '#{session.gpo}';
						//- 	//- })
						//- }
					//- }

					if (!self.tinymce && $('#description')[0] && tinymce) {
						self.tinymce = tinymce.init({
							menubar: false,
							statusbar: false,
							theme: 'inlite',
							inline: true,
							selector: "#description,#title",
							plugins: 'lists',
							valid_elements: '*[*]',
							setup: function (editor) {
								editor.addButton('footnote', {
									text: 'Add footnote',
									icon: 'link',
									onclick: function(){
										self.doc.properties.footnotes.push(
											''
										);
										editor.insertContent('<a v-if="doc.properties.footnotes && doc.properties.footnotes['+(self.doc.properties.footnotes.length - 1)+']" href="ftnref'+(self.doc.properties.footnotes.length)+'"><span class="super">'+(self.doc.properties.footnotes.length)+'</span></a>')
										//editor.insertContent('<span v-if="doc.properties.footnotes && doc.properties.footnotes['+(self.doc.properties.footnotes.length - 1)+']" class="super">'+(self.doc.properties.footnotes.length)+'</span>')
										$('#footnote'+self.doc.properties.footnotes.length - 1).focus()
									}
								})
							},
							selection_toolbar: 'bold italic underline strikethrough | bullist numlist | outdent indent blockquote | subscript superscript | footnote'
						});
					}
					if (self.position) {
						self.loadMap(function(dataCoords){
							self.latlng = dataCoords
							self.panZoom();
						})
					}
					self.sliderImg()
				},
				beforeDestroy: function(){
					//TODO clearTimout
				},
				methods: {
					ifNullThenArr(obj) {
						if (!obj) return [];
						return obj;
					},
					parsePu(obj) {
						if (!obj) {
							return {
								properties: {
									givenName: ''
								}
							}
						}
						return obj;
					},
					changeDocType(e) {
						var self = this;
						console.log(e.target.value)
						var ind = parseInt(e.target.value, 10);
						self.newDoc.tiind = ind;
					},
					changePlaceType(e) {
						var self = this;
						var url = e.target.value;
						var type = (e.target.value === '/json/usstates.json' ? 'State' : (e.target.value === '/json/us.json' ? 'Nation' : null));
						$.getJSON(url).then(async function(json){
							await console.log(json)
							self.newDoc.placetype = type;
							self.newDoc.tempGeo = await json.features;
							console.log(self.newDoc.tempGeo)
						})
						.catch((err)=>console.log(err))
					},
					changePlaceNew(e) {
						var self = this;
						console.log(e.target.value)
						var ind = parseInt(e.target.value, 10);
						console.log(ind)
						self.newDoc.place = (isNaN(ind) || !self.newDoc.tempGeo[ind] ? (!self.newDoc.tempGeo[self.newDoc.tempGeo.length-1] ? null : self.newDoc.tempGeo.length-1) : ind )
					},
					submitZip(e) {
						var self = this;
						$.post('/pu/getgeo/'+null+'/'+null+'/'+self.modal.zip+'')
						.then(function(href){
							window.location.href = href
						})
					},
					handleLocationOutcome(geolocation, pos) {
						var self = this;
						console.log(geolocation)
						var modal = document.getElementById('modal');
						if (!geolocation && modal) {
							self.modal.msg = 'geolocator didn\'t work. Please provide the zip code you vote from. ';
							self.modal.id = 'zip'
						} else if (geolocation) {
							//http://localhost:8686/sig/getgeo/5ca8cd51aa87b56585bedbb4/40.666473599999996/-111.8096681/null/null
							if (!pos || !pos.lat) {
								
							} else {
								$.post('/pu/getgeo/'+pos.lat+'/'+pos.lng+'/'+null+'')
								.then(function(href){
									window.location.href = href
								})
							}
							
						} else {
							if (!self.pu || !self.pu._id){
								
							}else {
								window.location.href = '/pu/getgeo/'+self.pu._id+''
							}
						}
					},
					sliderImg: function(){
						var self = this;
						if ($('#slider')[0]) {
							setInterval(function(){
								$('#slider').css('opacity',0);
								setTimeout(function(){
									if (self.sliderIndex > 3) {
										self.sliderIndex = 1;
									} else {
										self.sliderIndex += 1;
									}
									setTimeout(function(){
										$('#slider').css('opacity',1);
									},2000)
									
								},2000)
							},10000)
						} else {
							console.log('no slider')
						}
					},
					clickSlider: function(diff, doc){
						//`<a v-bind:click="" >${diff.user.username}<img class="avatar" src="${diff.user.avatar}"></img></a>`
						$('#diff'+doc.index).val(diff.ind)
					},
					changeDiff(e) {
						var self = this;
						console.log(e.target.value)
						self.dfi = (!isNaN(parseInt(e.target.value, 10)) ? parseInt(e.target.value, 10) : null);
					},
					navigateTo: function(url){
						window.location.href = url;
					},
					deleteEntry: function(doc) {
						$.post('/api/deleteentry/'+doc._id+'', function(res){
							window.location.href = '/menu/'+doc.properties.title.ind+'/'+doc.properties.chapter.ind+'';
						})
					},
					deleteMedia: function(ind) {
						var self = this;
						$.post('/api/deletemedia/'+self.doc._id+'/'+ind+'', function(res){
							self.doc = res;
						})
					},
					accordion: function(n, ind) {
						var self = this;
						if (!ind) {
							if (!self.accordions[n].length) {
								self.dat.forEach(function(datas, i){
									if (i === n) {
										self.accordions[n] = datas.map(function(doc){return doc.index})
									}
								});
								self.accordions[n].sort();
							} else {
								self.accordions[n] = [];
							}
						} else {
							if (self.accordions[n].indexOf(ind) === -1) {
								self.accordions[n].push(ind);
								self.accordions[n].sort();
							} else {
								self.accordions[n].splice(self.accordions[n].indexOf(ind), 1);
							}
						}
					},
					parseBool: function(item) {
						if (!item) return false;
						return true;
					},
					toggleExport: function() {
						this.export = !this.export;
					},
					getHTML: function(type, str) {
						var self = this;
						var span = document.createElement(type);
						span.innerHTML = str;
						return span.outerHTML;
					},

					dPathAttr: function() {
						var self = this;
						var thickness = (!thickness ? 50 : thickness);
						var nw = (!self.wWidth ? window.innerWidth : self.wWidth);
						var nh = (!self.wHeight ? window.innerHeight : self.wHeight);
						
						var d;
						if (self.type === 'draw') {
							d = "M0,0v"+nh+"h"+nw+"V0H0L0,0z"
						} else {
							d = "M0,0v"+nh+"h"+nw+"V0H0L0,0z "+
							"M"+(thickness)+","+(thickness)+"H"+(nw - thickness)+"V"+(nh - thickness)+"H"+(thickness)+"V"+(thickness)+"z "
						}
						return d;
					},
					widthRectAttr: function(plus,type){
						var nw = this.getSize(type).nw;
						return nw - ((self.thickness + plus) * 2);
					},
					heightRectAttr: function(plus,type){
						var nh = this.getSize(type).nh;
						return nh - ((self.thickness + plus) * 2);
					},
					panZoom: function(){
						var self = this;
						//console.log(self.map)
						if (self.map) {
							$.post('/panzoom/'+self.map.getCenter().lat+'/'+self.map.getCenter().lng+'/'+self.map.getZoom()+'', function(result){
							})
						}
						
					},
					importCsv: function(e){

						var self = this;
						var file = document.getElementById('importcsv').files[0];//e.target.files[0];
						var reader = new FileReader();
						
						reader.onloadend = function(e) {
							var fd = new FormData();

							fd.append("csv", file);
							
							var uploadurl = '/api/importcsv/'+(!self.doc || self.doc === '' ? self.data[self.dindex]._id : self.doc._id )+'/csv';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
								success: function(response) { 
									self.doc = response;
									window.location.reload(true)
								}
								
							})
						}
						reader.readAsDataURL(file)
						
					},
					submitForm: function(ind){
						$('#form_'+ind+'').submit()
					},
					parseObj: function(obj) {
						if (!obj) return '';
						return obj;
					},
					toggleEdit: function(ind) {
						var self = this;
						this.edit = (!this.edit ? ind : null);
					},
					checkNameValidity(type, aSearchTerm, aMsg, event) {
						var self = this;
						var elem = event.target;//document.getElementById(aID);
						for (var i = 0; i < elem.value.length; i++) {
							if (aSearchTerm.indexOf(elem.value.charAt(i)) !== -1) {
								elem.setAttribute("aria-invalid", "true");
							} else {
								elem.setAttribute("aria-invalid", "false");
							}
						}
						var check = elem.value;
						if (check !== '' && type === 'givenName') {
							var url = check.replace(' ', '_');
							$.post('/check/'+check).done(function(result, res){
								console.log(result, res)
								self.avail = (result === 'Available')
							})
						}
					},
					initSig() {
						var self = this;
						self.type = 'draw';
						document.getElementById('viewer').scrollIntoView();

					},
					setSigData(i, val, ts, can) {
						var self = this;
						
						Vue.set(self.can, parseInt(i,10), can)
						console.log(self.ts, ts)
						if (!Array.isArray(self.ts)) {
							self.ts = [];
						}
						Vue.set(self.ts, 0, ts)
					},
					updateSignature(index, url) {
						Vue.set(this.signatureDataUris, 0, url);
					},
					signatureToBlob(cb) {
						var self = this;
						if (!HTMLCanvasElement.prototype.toBlob) {
						 Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
							value: function (callback, type, quality) {
								var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
								len = binStr.length,
								arr = new Uint8Array(len);
								for (var i = 0; i < len; i++ ) {
									arr[i] = binStr.charCodeAt(i);
								}
								callback( new Blob( [arr], {type: type || 'image/png'} ) );
							}
						 });
						}
						self.can[0].toBlob(function(blob){
							cb(blob);
						}, 'image/png')
					},
					saveSignature(){
						var self = this;
						var fd = new FormData();
						self.signatureToBlob(function(blob){
							
							fd.append('img', blob);
							fd.append('_csrf', '#{csrfToken}');
							fd.append('ts', self.ts);

							var uploadurl = '/sig/uploadsignature/'+self.doc._id+'/'+self.pu._id+'';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
								success: function(response) {
									self.mode = 'blog';
									window.location.href = response
								}
							})
						})
					},
					activateMap(){
						var self = this;
						var mapActive = self.mapActive;
						if (!mapActive) {
							document.getElementById('viewer').scrollIntoView();
						} else {
							document.getElementById('inputs').scrollIntoView();
						}
						self.mapActive = !mapActive;
					},
					
					addMapBlob() {
						var self = this;
						var ind = self.doc.properties.media.length;
						var mapActive = self.mapActive;
						self.mapActive = !mapActive;
						document.getElementById('inputs').scrollIntoView();

						self.dataLayer.disableEdit();
						self.addNewMedia(self.doc._id, ind, function(){
							leafletImage(self.map, function(err, canvas){
								if (err) {
									return console.log(err)
								}
								$('a[id*=deletemedia]').hide();
								var im = new Image()
								im.src = canvas.toDataURL('image/png');
								im.onload = function(){
									self.checkImage(im, canvas, im.width, im.height, 1025, 1025, ind, 'map');
									setTimeout(function(){
										var img = document.querySelector('img#return'+ind+'');
										var can = $('#canvas'+ind+'')[0];
										var w = img.width;
										var h = img.height;
										can.width = w;
										can.height = h;
										var ctx = can.getContext("2d");
										ctx.drawImage(img, 0, 0, w, h);
										self.uploadBlob(img, can, ind, function(){
											var dataurl = can.toDataURL("image/png", 0.8);
											self.doc.properties.media[ind].thumb = dataurl.replace(/data:image\/png;base64,/, '');
										})
									},2000)
								}
							})
						});
					},
					addNewMedia: function(id, index, cb) {
						var self = this;
						$.post('/api/newmedia/'+id+'/'+index+'', function(res) {
							self.doc.properties.media.push(res);
							cb()
						})
					},
					handleFile: function(dindex, index) {
						var self = this;
						self.dindex = dindex;
						self.file = document.getElementById('media_'+index).files[0];
						self.processImage(index);
					},
					processJson(){
						var self = this;
						var dataurl = null;
						var file = self.file;
						if (!file) return;
						console.log(file)
						// TODO validate json type somehow before upload
						var reader = new FileReader();
						reader.onloadend = function(e) {
						//- reader.addEventListener("load", function () {
							var fd = new FormData();
							var blob = this.result;
							console.log(blob)
							fd.append("json", file);
							fd.append('_csrf', '#{csrfToken}');

							var uploadurl = '/api/importjson/'+self.doc._id+'/json';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
									success: function(response) { 
										self.doc = response
										console.log(response)
									}
								})
						}
						//- }, false)
						reader.readAsDataURL(file);
						
					},
					processImage: function(imgindex) {
						var self = this;
						var dataurl = null;
						var file = self.file;
						if (!file) return;
						var imagefile = file.type;
						var imageTypes= ["image/jpeg","image/png","image/jpg","image/svg+xml"];
						if(imageTypes.indexOf(imagefile) === -1) {
							$("#info").html("<span class='msg-error'>Please Select A valid Image File</span><br /><span>Only jpeg, jpg, png, and pdf types allowed</span>");
							return false;
							
						} else {
							var reader = new FileReader();
							
							reader.onloadend = function(e) {
								var img = document.getElementById('return'+imgindex+'');
								img.src = e.target.result;
								var type = imagefile.split('image/')[1];
								img.onload = function() {
									$('#media').val('');
									var can = $('#canvas'+imgindex+'')[0];
									var maxWidth = 1025 ;
									var maxHeight = 1025 ;
									var w = img.width;
									var h = img.height;
									can.width = w;
									can.height = h;
									var ctx = can.getContext("2d");
									ctx.drawImage(img, 0, 0);
									self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, type);
								}
								
							}
							reader.readAsDataURL(file);
						}
					},
					checkImage: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype) {
						var self = this;
						if (h > maxHeight || w > maxWidth) {
							self.reSize(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
						} else {
							if (imgtype === 'map') {
								var im = document.querySelector('img#return'+imgindex+'');
								im.setAttribute('src', can.toDataURL('image/png'))
							} else {
								if (maxHeight === 400) {
									self.drawThumb(img, can, w, h, imgindex, imgtype)
								} else {
									self.drawFull(img, can, w, h, imgindex, imgtype)
								}
							}
						}
						
					},
					reSize: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype){
						can.height = h*0.99;
						can.width = w*0.99;

						var can2 = document.createElement('canvas');
						can2.width = w*0.99;
						can2.height = h*0.99;
						var ctx2 = can2.getContext('2d');
						var ctx = can.getContext('2d');
						ctx2.drawImage(img, 0, 0, w*0.99, h*0.99);
						ctx.drawImage(can2, 0, 0, w*0.99, h*0.99, 0, 0, w*0.99, h*0.99);
						w = w*0.99;
						h = h*0.99;
						img.width = w;
						img.height = h;
						this.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
					},
					uploadBlob: function(img, can, imgindex, cb) {
						var self = this;
						var orientation = 'portrait'
						if (can.width > can.height) { 
							orientation = 'landscape' 
						} else { 
							orientation = 'portrait' 
						}

						if (!HTMLCanvasElement.prototype.toBlob) {
						 Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
							value: function (callback, type, quality) {
								var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
								len = binStr.length,
								arr = new Uint8Array(len);
								for (var i = 0; i < len; i++ ) {
									arr[i] = binStr.charCodeAt(i);
								}
								callback( new Blob( [arr], {type: type || 'image/png'} ) );
							}
						 });
						}
						can.toBlob(function(blob) {
							var fd = new FormData();
							fd.append("img", blob);
							var uploadurl = '/api/uploadmedia/'+self.doc.index+'/'+imgindex+'/png';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
									success: function(response) { 
									img.onload = function () {
										self.doc.properties.media[imgindex].image_abs = response;
										self.doc.properties.media[imgindex].image = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].thumb_abs = response;
										self.doc.properties.media[imgindex].thumb = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].orientation = orientation;
										cb();
									}
									img.src = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
								}
							})
						}, 'image/png');
					},
					drawFull: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
					// console.log(w,h)
						ctx.drawImage(img, 0, 0, w, h);
						self.uploadBlob(img, can, imgindex, function(){
							var can = $('#canvas'+imgindex+'')[0];
							var maxWidth = 400 ;
							var maxHeight = 400 ;
							var w = img.width;
							var h = img.height;

							self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype);
						})
						
					},
					drawThumb: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
						
						ctx.drawImage(img, 0, 0, w, h);
						var dataurl = can.toDataURL("image/png", 0.8);
						setTimeout(function(){
							self.doc.properties.media[imgindex].thumb = dataurl.replace(/data:image\/png;base64,/, '');
							//$('#inputthumb'+imgindex+'').val(dataurl.replace(/data:image\/png;base64,/, ''));
							
						}, 100);
					},
					getCoordInds(latlngs, latlng) {
						
					},
					latlngsToArr(latlngs, cll){
						if (!Array.isArray(latlngs)) {
							return;
						}
						return latlngs.map(function(latlng, h){
							if (!Array.isArray(latlng)) {
								self.h = null;
								return [latlng.lng,latlng.lat];
							} else {
								if (latlng[0].lat && (latlng[0].lat !== latlng[latlng.length-1].lat || latlng[0].lng !== latlng[latlng.length-1].lng)) {
									latlng.push(latlng[0])
								}
								return latlng.map(function(ll, i){
									if (!Array.isArray(ll)) {
										if (ll.lat === cll.lat && ll.lng === cli.lng) {
											self.h = h;
											self.i = i;
											self.lvl = 'hi'
										}
										return [ll.lng,ll.lat]

									} else {
										if (ll[0].lat && (ll[0].lat !== ll[ll.length-1].lat || ll[0].lng !== ll[ll.length-1].lng)) {
											ll.push(ll[0])
										}
										return ll.map(function(l, j) {
											if (!Array.isArray(l)) {
												if (l.lat === cll.lat && l.lng === cll.lng) {
													self.h = h;
													self.i = i;
													self.j = j;
													self.lvl = 'hij'
												}
												return [l.lng,l.lat]

											} else {
												if (l[0].lat && (l[0].lat !== l[l.length-1].lat || l[0].lng !== l[l.length-1].lng)) {
													l.push(l[0])
												}
												return l.map(function(k, m){
													if (!Array.isArray(k)) {
														if (k.lat === cll.lat && k.lng === cll.lng) {
															self.h = h;
															self.i = i;
															self.j = j;
															self.m = m;
															self.lvl = 'hijm';
														}
														return [k.lng,k.lat]
													} else {
														console.log('giant array')
													}
												})
											}
										})
									}
								})
							}
							
						});
					},
					handleGeoJson(e){
						var self = this;
						self.file = 
							//document.getElementById('lyr_'+doc._id)
							e.target.files[0];
						self.processJson()
					},
					getLayers(id) {
						//- self.lyr[item._id]
						var self = this;
						$.get('/api/geointersect/'+id+'', function(res){
							if (res.length === 1 && res[0]._id === self.doc._id) {
								$.get('/')
							}
							console.log(res)
						})
					},
					loadLayer(item) {
						console.log(item)
						return L.GeoJSON.geometryToLayer(item);
					}
					 /*Leaflet requires reversed geo-coordinate (lat, lng)*/,
					loadMap(cb) {
						var self = this;
						var dataLayer;
						var dataCoords;
						var map = new L.map('map', { 
							center: [
								(!self.latlng ? 40.7608 : self.latlng.lat),
								(!self.latlng ? -111.8910 : self.latlng.lng)
							], 
							zoom: (!self.position ? 6 : self.position.zoom),
							zoomControl: false,
							minZoom: 2,
							maxZoom: 18,
							editable: true,
							renderer: L.canvas(),
							preferCanvas: true
						});
						if (self.infowindow === 'tooltip') {
							L.control.zoom({
								position:'bottomleft'
							}).addTo(map);
						} else {
							L.control.zoom({
								position:'topleft'
							}).addTo(map);
						}
						
						var options3 = {
							
							attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
						};
						L.tileLayer('https://api.mapbox.com/styles/v1/tbushman/ciq7gm0ov008kbfm580v9mm9c/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoidGJ1c2htYW4iLCJhIjoiSmI0aU94OCJ9.SZytljBzoWupPUYeu_OR9A', {renderer: L.canvas({padding:0.5}), bounds: map.getBounds().pad(1000)}).addTo(map);
						self.map = map
						if (!self.dataLayer && self.doc) {
							// generate geographic points from data
							if (self.doc && self.doc !== '') {
								//- var key = 'dataLayer';
								
								var myRenderer = L.canvas({ padding: 0.5 });
								self.dataLayer = self.loadLayer(self.doc);
								
								self.map.addLayer(self.dataLayer);
								self.latlngs = self.dataLayer.getLatLngs();
								if (self.layers.length) {
									self.layers.forEach(function(item){
										self.lyr[item._id] = self.loadLayer(item);
										self.map.addLayer(self.lyr[item._id])
									})
								}
								//- self.dataLayer.on('dragend', function(e){
								//- 	var latlngs = [];
								//- 	console.log(e.target.getLatLngs)
								//- 	e.target.getLatLngs().forEach(function(latlng){
								//- 		console.log(latlng)
								//- 		if (latlng) {
								//- 			latlng.forEach(function(ll){
								//- 				console.log(ll)
								//- 				latlngs.push([ll.lng,ll.lat])
								//- 			})
								//- 			latlngs.push([latlng[0].lng, latlng[0].lat])
								//- 		}
								//- 	})
								//- 	self.doc.geometry.coordinates = latlngs
								//- })
								map.on('editable:editing', function (e) {
									e.layer.setStyle({color: 'DarkRed'});
								});
								self.map.on('editable:vertex:dragstart', async function(e){
									var cll = e.vertex.latlng.__vertex.latlng;
									var dll = self.dataLayer.getLatLngs();
									var lvl = 0;
									var p = 0;
									var dl;
									var lll = self.dataLayer.getLatLngs();
									self.latlngs = lll;
								})
								self.map.on('editable:vertex:dragend', function(e){
									console.log(e)
									var cll = e.vertex.latlng.__vertex.latlng;
									var dll = self.dataLayer.getLatLngs();
									var lvl = 0;
									var p = 0;
									var dl;
									self.latlngs = dll;
									self.doc.geometry.coordinates = self.latlngsToArr(dll, cll);
								})
								var coords = self.latlngs;
								if (coords) {
									latlng = L.latLngBounds(coords).getCenter();
								} else {
									console.log(self.latlngs)
									self.latlngs = self.dataLayer.getLatLngs();
									latlng = L.latLngBounds(self.latlngs).getCenter();
								}
								// TODO admin only for certain things?
								if (self.loggedin && self.loggedin !== '') self.dataLayer.enableEdit();

								self.lMarker = L.marker(latlng, {draggable: true}).addTo(map);
								
							}

							self.map.panTo(latlng);
							
							cb(latlng)

						} else {
							cb(null)
						// console.log('when?')
						}
					}
				}
			});
