doctype strict
html
	head
		meta(charset="utf-8")
		meta(http-equiv="X-UA-Compatible", content="IE=edge; charset=utf-8")
		//- meta(name="google-site-verification", content="p4ANTDMaoAMsiWW5CwWtiY9v8mEPGv8KhQetzWrJlwc")
		title= appTitle
		meta(name="viewport", content="width=device-width, initial-scale=1.0")
		base(href="")
		link(href="/stylesheets/gpo.css")
		link(rel="stylesheet", href="/stylesheets/style.css?version=1")
		link(rel="stylesheet", href="/stylesheets/leaflet.css")
		link(rel="stylesheet", href="/stylesheets/leaflet.draw.css")
		//- link(href="https://api.tiles.mapbox.com/mapbox.js/v2.1.6/mapbox.css")
		script(type="text/javascript", src="/scripts/vue.js")
		script(type="text/javascript", src="/scripts/jquery.min.js")
		script(type="text/javascript", src="/scripts/jquery-ui.min.js")
		script(type="text/javascript", src="/scripts/moment-with-locales.min.js")
		script(type="text/javascript", src="/scripts/marked.min.js")
		script(type="text/javascript", src="/scripts/leaflet.js")
		script(type="text/javascript", src="/scripts/Path.Drag.js")
		script(type="text/javascript", src="/scripts/Leaflet.Editable.js")
		script(type='text/javascript', src='/scripts/leaflet-image_0_4_0.js')
		//- script(type="text/javascript", src="/scripts/jszip.min.js")
		script(type="text/javascript", src="/scripts/signaturePad.js")
		script(type="text/javascript", src="/scripts/htmldiff.js")
		script.
			var module = {};
		//- script(type="text/javascript", src="/scripts/xth.js")
		//- script(type="text/javascript", src="/scripts/tinymce.min.js?apiKey=yb2pwtctf7qznwdoo61w3kyj127j61gch5uhhzneop9mfkg7")
		//- script(src="https://cdn.tiny.cloud/1/yb2pwtctf7qznwdoo61w3kyj127j61gch5uhhzneop9mfkg7/tinymce/5/tinymce.min.js" referrerpolicy="origin")

		script(type="text/javascript", src="https://cloud.tinymce.com/stable/tinymce.min.js?apiKey=yb2pwtctf7qznwdoo61w3kyj127j61gch5uhhzneop9mfkg7")
	body
		block page
		block header
		block content

		div#gpresult
		
		#map
		a#publish_logo(class= (mapActive?'mapactive':'') href="https://github.com/tbushman/esta" target="_blank")
			img(src="/images/publish_logo.svg")
		if (!mapActive)
			a#publish_logo.tb-font-xxxs(href="http://bli.sh/pp/blish", target="_blank", style="top: calc(100vh - calc(var(--thumbw) * 1.1));right: 23px;margin:0;text-align:right;bottom: auto;") Privacy policy

		script(type="text/javascript").
			Vue.prototype.moment = moment;
			Vue.prototype.marked = marked;
			Vue.prototype.SignaturePad = SignaturePad;
			Vue.prototype.$ = $;
			Vue.prototype.htmldiff = htmldiff;
			Vue.prototype.window = window;
			//- Vue.prototype.d3 = d3;
			//- Vue.prototype.xth = xth;
			Vue.prototype.L = L;
			//- Vue.prototype.CensusReporter = CensusReporter;
			if (typeof tinymce === 'object') Vue.prototype.tinymce = tinymce;
			new Vue({
				el: '#vue',
				data: function data(){
					return {
						tempstyles: [],
						colorTimeout: null,
						buf: null,
						//- attribute: null,
						//- attributes: [],
						availablelayers: this.ifNullThenArr(!{JSON.stringify(availablelayers)}),
						c: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928","#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b","#e377c2","#7f7f7f","#bcbd22","#17becf"],
						//['#39B54A', '#D9E021', '#FBB03B', '#FC644D', '#ED1C24'],
						//- lvl: 'h',
						wWidth: window.innerWidth,
						wHeight: window.innerHeight,
						btn: { x: (window.innerWidth / 2), 
							y: (window.innerHeight/ 2),
							r: 21,
							vis: (!this.mapActive || !this.mapEdit ? null : 'block')
						},
						//- h: 0,
						//- i: 0,
						//- j: 0,
						//- m: 0,
						signable: this.parseBool(!{JSON.stringify(signable)}),
						unsigned: this.parseBool(!{JSON.stringify(unsigned)}),
						avail: this.parseBool(!{JSON.stringify(avail)}),
						type: this.parseObj(!{JSON.stringify(type)}),
						pu: this.parsePu(!{JSON.stringify(pu)}),
						loggedin: (this.parseObj(!{JSON.stringify(session)}) !== '' && this.parseObj(!{JSON.stringify(session.loggedin)}) !== '' ? this.parseObj(!{JSON.stringify(session.loggedin)}) : null ),
						menu: this.parseObj(!{JSON.stringify(menu)}),
						dat: this.parseObj(!{JSON.stringify(dat)}),
						doc: this.parseObj(!{JSON.stringify(doc)}),
						layers: this.parseObj(!{JSON.stringify(layers)}),
						position: (!this.parseObj(!{JSON.stringify(session.position)}) ? {lat: 40, lng: -111.89, zoom: 6}/*null*/ : this.parseObj(!{JSON.stringify(session.position)})),
						edit: (this.parseObj(!{JSON.stringify(doc)}) === '' ? null : this.parseObj(!{JSON.stringify(doc)}).index),
						//- chindexes: [],
						chindex: 0,
						//- dindexes: [],
						did: (this.parseObj(!{JSON.stringify(doc)}) === '' ? null : this.parseObj(!{JSON.stringify(doc)})._id),
						cursor: null,
						//- input: '',
						//- fixedPug: '',
						map: '',
						mapActive: (this.parseBool(!{JSON.stringify(mapActive)})),
						mapReady: false,
						mapEdit: false,
						mapEditable: false,
						dataLayer: '',
						lMarker: '',
						thickness: 45,
						res: (window.innerWidth < 600),
						dPath: this.dPathAttr(),
						tinymce: '',
						dfi: 0,
						diff: null,
						web: true,
						export: this.parseBool(!{JSON.stringify(exports)}),
						ff: this.parseObj(!{JSON.stringify(ff)}),
						newDoc: {tempGeo:[],placetype:'',place:null,tiind:null,xmlid:'',chind:null,chtitle:''},						
						placemenu: false,
						
						placetypes: [{
							ind: 0,
							name: 'Nation',
							url: '/json/usstates.json'
						},
						{
							ind: 1,
							name: 'State',
							url: '/json/usstates.json'
						},
						{
							ind: 2,
							name: 'County',
							url: '/json/uscounties.json'
						}],
						modal: {msg:null},
						uploadisreplace: false,
						uploadchtitle: null,
						dragind: null,
						latlngs: null,
						//- gp: (this.parseObj(#{session.importgdrive}) !== '' ? this.parseObj(!{JSON.stringify(gp)}) : null),
						sliderIndex: 1,
						sliderInterval: '',
						sliderTimeout1: '',
						sliderTimeout2: '',
						str: this.parseObj(!{JSON.stringify(str)}),
						ts: this.ifNullThenArr(!{JSON.stringify(ts)}),
						can: [],
						lyr: {},
						geo: [],
						tis: [
							{
								ind: 0,
								name: 'in support of legislation',
								code: 'BILLS-',
								chapter: [
									{
										ind: 115,
										name: 'United States Congress',
										code: 'hres',
										section: [
											{
												ind: 108,
												name: 'House Simple Resolution (H. Res.)',
												code: 'ih'
											}
										]
									}
								]
							},
							{
								ind: 1,
								name: 'in Solidarity',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							},
							{
								ind: 2,
								name: 'Candidate for Public Office',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							},
							{
								ind: 3,
								name: 'Environmental Impact Statement',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							},
							{
								ind: 4,
								name: 'Geography',
								chapter: [
									{
										ind: 0,
										name: 'Jurisdiction'
									}
								]
							}
						],
						xml: //this.parseXML(
							this.parseObj(!{JSON.stringify(xml)})
						//)
						,
						xmlnode: '',
						accordions: [[]],
						sliderOpacity: 1,
						gpo: null,
						latlng: {lat: 40, lng: -111.8},
						//- lyrs: [],
						credit: this.getCredit(),
						base: 0,
						baseMaps: [
							{
								url: 'https://api.mapbox.com/styles/v1/tbushman/ciq7gm0ov008kbfm580v9mm9c/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoidGJ1c2htYW4iLCJhIjoiSmI0aU94OCJ9.SZytljBzoWupPUYeu_OR9A',
								attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>'
							},
							{
								url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
								attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
							}
							
						],
						zfactor: (0.01 * (!this.map ? 6 : (18 - this.map.getZoom() ) )),
						cZF: null,
						viewerList: false,
						censusVars: null,
						censusLoad: {tempGeo:[],placetype:'',cats:null,cat:null} ,
						json: {}
						
					}
				},
				components: {
					canvasc: {
						data: function() {
							return {
								signaturePad: null,
								ctx: null,
								dataUrl: null,
								pts: null,
								cW: window.innerWidth,
								cH: window.innerHeight,
								pu: this.$parent.pu
							}
						},
						mounted: function(){
							var self = this;
							self.signaturePad = new SignaturePad(self.$refs.canv, {
								onEnd: async function() {
									self.$refs.canv.style['letter-spacing'] = '0px'
									var ctx = self.$refs.canv.getContext('2d');
									ctx.font = '12px serif';
									
									var ts = '/'+self.pu.properties.givenName+'/'+moment().utc().format();
									ctx.beginPath();
									ctx.fillText(ts, 23, 132);
									ctx.closePath();
									self.dataUrl = self.signaturePad.toDataURL()
									self.pts = self.signaturePad.toData();
									self.$emit('update', self.dataUrl, ts, self.$refs.canv);
									
								},
								onBegin: function() {
									// clear timestamp only
									var ctx = self.$refs.canv.getContext('2d');
									ctx.clearRect(23, 123, 277, 32);

								}
							});
						},
						methods: {
							clearCanv(){
								var self = this;
								var ctx = self.$refs.canv.getContext('2d');
								ctx.clearRect(0, 0, 300, 150);
								
							}
						},
						template: 
						`
						<div class="row" style="text-align: center;">
						<canvas
							id="maincanvas"
							ref="canv"
						></canvas>
						<a role="button" @click="clearCanv" title="Clear signature" v-text="'Clear signature'"></a>
						</div>
						`
					}
				},
				watch: {
					accordions: {
						deep: true,
						handler(accordions) {
							var self = this;
							self.accordions = accordions
						}
					}
				},
				
				updated: function(){
					var self = this;
					//- if (self.colorTimeout) clearTimeout(self.colorTimeout);
				},
				mounted: function(){
					$(document).ready(function(){
						document.addEventListener('keydown', function(event) {
							var keyName = event.key;
							if (keyName === 'Enter') event.preventDefault()
						});
						setTimeout(function(){
							$('.submenu.drop').slideUp(100);
							$('.slidedown').slideUp(100);
						},3000)

					})
					var self = this;
					$(document).on('click', '.href', function(e){
						e.stopPropagation();
					});
					var modal = document.getElementById('modal');
					if (self.type === 'geo') {
						// prompt geolocation
						var pos = null;
						if (navigator.geolocation) {
							var options = {
								enableHighAccuracy: true,
								timeout: 5000,
								maximumAge: 0
							};
							navigator.geolocation.getCurrentPosition(function(position) {
								pos = {
									lat: position.coords.latitude,
									lng: position.coords.longitude
								};
								//- console.log(pos)
								self.handleLocationOutcome(true, pos);
							}, function() {
								self.handleLocationOutcome(false, pos);
							}, options);
						} else {
							// Browser doesn't support Geolocation
							self.handleLocationOutcome(false, pos);
						}
					
					} else if (!self.mapActive) {

						if (!self.doc || self.doc === '') {
							if (!self.dat || self.dat === '') {
								self.accordions = [[]];
							} else {
								self.accordions = self.dat.map(function(data){
									return []
								});
							}
						} else {
							if (!self.dat || self.dat === '') {
								self.accordions = [[self.doc.index]];
							} else {
								self.accordions = self.dat.map(function(data){return data.map(function(doc){return doc.index})});
							}
							self.edit = self.doc._id;
							self.did = self.edit;
							
						}
					}

					if (self.tinymce === ''  && $('#description')[0] && typeof tinymce === 'object') {
						//- console.log($('#description')[0])
						self.tinymce = tinymce.init({
							menubar: false,
							statusbar: false,
							theme: 'inlite',
							inline: true,
							selector: "#description,#title",
							plugins: 'lists',
							valid_elements: '*[*]',
							setup: function (editor) {
								//- editor.ui.registry.addButton('footnote', {
								editor.addButton('footnote', {
									text: 'Add footnote',
									icon: 'link',
									onclick: function(){
										self.doc.properties.footnotes.push(
											''
										);
										editor.insertContent('<a v-if="doc.properties.footnotes && doc.properties.footnotes['+(self.doc.properties.footnotes.length - 1)+']" href="ftnref'+(self.doc.properties.footnotes.length)+'"><span class="super">'+(self.doc.properties.footnotes.length)+'</span></a>')
										//editor.insertContent('<span v-if="doc.properties.footnotes && doc.properties.footnotes['+(self.doc.properties.footnotes.length - 1)+']" class="super">'+(self.doc.properties.footnotes.length)+'</span>')
										$('#footnote'+self.doc.properties.footnotes.length - 1).focus()
									}
								})
							},
							selection_toolbar: 'bold italic underline strikethrough | bullist numlist | outdent indent blockquote | subscript superscript | footnote'
						});
					}
					const tempstyles = (!self.doc || self.doc.properties.layers.length === 0 ? [] : self.doc.properties.layers)
					self.tempstyles = JSON.parse(JSON.stringify(tempstyles));
					window.addEventListener('resize', self.resizeFrame);

					self.loadMap(function(dataCoords){
						
						//- console.log(dataCoords)
						//- if (dataCoords){
						//- 	self.latlng.lng = dataCoords.lng;
						//- 	self.latlng.lat = dataCoords.lat;
						//- 	self.panZoom();
						//- } else {
						//- 	self.latlng.lat = 40;
						//- 	self.latlng.lng = -111;
						//- 	self.panZoom();
						//- }
						//- self.mapReady = true;
						self.map.on('dragstart', function(e){
							self.viewerList = false;
						});
						//- self.map.on('viewreset', function(e){
						//- 	if (self.geo.length === 0) {
						//- 		self.viewerList = false;
						//- 	} else {
						//- 		self.viewerList = true;
						//- 	}
						//- })
						//- self.map.on('zoomstart', function(e){
						//- 	self.viewerListState = JSON.parse(JSON.stringify(self.viewerList));
						//- })
						self.map.on('zoomend', function(e){
							//- if (self.geo.length === 0) {
							//- 	self.viewerList = false;
							//- } else if (self.viewerList && self.geo.length > 0){
							//- 	self.viewerList = true;
							//- } else {
							//- 	self.viewerList = false;
							//- }
							var coord = self.lMarker.getLatLng();
							var xy = self.map.latLngToLayerPoint(coord);
							var x = xy.x;
							var y = xy.y;
							self.btn.x = x;
							self.btn.y = y;
						})
						//- self.map.on('zoomstart', function(e){
						//- 	self.btn.x = window.innerWidth / 2;
						//- 	self.btn.y = window.innerHeight / 2;
						//- })
						//- self.map.on('preclick', function(e){
						//- 	if (self.geo.length === 0) {
						//- 		self.viewerList = false;
						//- 	} else if (self.geo.length > 0){
						//- 		self.viewerList = true;
						//- 	} else {
						//- 		self.viewerList = false;
						//- 	}
						//- })
						//- self.map.on('preclick', function(e){
						//- 	if (self.viewerList) {
						//- 		self.viewerList = false;
						//- 	}
						//- })

						if ($('#slider')[0] && (!self.sliderInterval || self.sliderInterval === '')) {
							var int = 8000;
							self.sliderImg(int)
						}

					})
				},
				beforeDestroy: function(){
					//TODO clearTimout
					var self = this;
					clearInterval(self.sliderInterval);
					clearTimeout(self.sliderTimeout1);
					clearTimeout(self.sliderTimeout2)
					if (self.colorTimeout) clearTimeout(self.colorTimeout);
					window.removeEventListener('resize', self.resizeFrame)

				},
				methods: {
					parseObj: function(obj) {
						if (!obj) return '';
						return obj;
					},
					parseBool: function(item) {
						if (!item) return false;
						return true;
					},
					ifNullThenArr(obj) {
						if (!obj) return [];
						return obj;
					},
					parsePu(obj) {
						if (!obj) {
							return {
								properties: {
									givenName: ''
								}
							}
						}
						return obj;
					},
					getCredit() {
						var self = this;
						var credit = null;
						if (self.layers && self.layers.length > 0) {
							var credits = self.layers.map(function(layer){ return (!layer.properties.credit ? '' : layer.properties.credit)}).join(' | ');
							credit = (!self.doc || !self.doc.properties.credit ? '' : self.doc.properties.credit);
							credit += credits;
						} else {
							credit = (!self.doc || !self.doc.properties.credit ? '' : self.doc.properties.credit);
						}
						return credit
					},
					resizeFrame(e) {
						var self = this;
						self.dPath = self.dPathAttr()
						self.wWidth = window.innerWidth;
						self.wHeight = window.innerHeight;
					},
					subDropdown(e) {
						var self = this;
						if (!$(e.target).next('.slidedown')) {
					
							return;
						} else {
							var sub = $(e.target).next('.slidedown')[0];
							//- console.log(e.target.nextSibling)
							//- console.log(sub)
							$('.drop').not($(e.target)).removeClass('active');
							$(sub).slideToggle(100);
							$(e.target).toggleClass('active');
						}
					},
					mainDropdown(e) {
						var self = this;
						if ($('.dropdown').hasClass('active')) {
							$('.dropdown').removeClass('active');
						} else {
							$('.dropdown').addClass('active');
						}
						$('.submenu.drop').slideToggle(100);
					},
					getGpo() {
						var self = this;
						$.get(
							'/api/gpo'
						)
						.then(function(data){
							//- console.log(data)
							self.gpo = JSON.parse(data);
						})
						.catch(function(err){
							console.log(err)
						})
					},
					changeBase(i, e) {
						var self = this;
						var credit = self.credit + ' | ' + self.baseMaps[self.base].attribution;
						if (e.target.checked) {
							self.base = i
							self.tilelayer.remove();
							self.tilelayer = L.tileLayer(self.baseMaps[self.base].url, {renderer: L.canvas({padding:0.5}), bounds: self.map.getBounds().pad(1000), attribution: credit}).addTo(self.map);
						}

					},
					layerAdd(id) {
						var self = this;
						if (self.json[id]) self.lyr[id] = self.loadLayer(self.json[id], id);
						if (self.lyr[id].options) self.lyr[id].options.interactive = true;
						//- self.map.addLayer(self.lyr[id]);
						var bounds = self.lyr[id].getBounds();
						self.map.fitBounds(bounds);
					},
					async addLayer(id, e) {
						var self = this;
						var tlrs = self.tempstyles.filter(function(item){
							return item.lid === id
						})[0];
						var style;
						if (!tlrs) { 
							style = {
								lid: id,
								buckets: 1,
								colors: [self.c[0]],
								key: ''
							};
						} else { 
							style = tlrs;
						}
						var ind = null;
						var thisAvailableLayer = await self.availablelayers.filter(function(item, i){
							if (item._id === id) {
								ind = i;
							} 
							return item._id === id
						})[0];
						var thisLayer = await self.layers.filter(function(item, i){
							return item._id === id
						})[0];
						if (!thisLayer && thisAvailableLayer) {
							if (ind !== null && self.json[id]) {
								self.availablelayers.splice(ind, 1);
								self.layers.push(thisAvailableLayer);
								await self.doc.properties.layers.push(style);
								self.layerAdd(id)
							}
						}
					},
					async removeLayer(id, e) {
						var self = this;
						var keys = self.doc.properties.layers.map(function(item){return item.lid})
						var ind = null;
						var thisLayer = await self.layers.filter(function(item, i){
							if (item._id === id) {
								ind = i;
							} 
							return item._id === id
						})[0];
						var thisAvailableLayer = self.availablelayers.filter(function(item, i){
							return item._id === id;
						})[0]
						if (thisLayer && !thisAvailableLayer) {
							if (ind > -1) {
								self.layers.splice(ind, 1);
								self.doc.properties.layers.splice(keys.indexOf(id), 1);
							}
							self.availablelayers.push(thisLayer);
						}
						if (self.doc.properties.layers && self.doc.properties.layers.length === 0 && typeof self.dataLayer.getBounds === 'function') {
							var bounds = self.dataLayer.getBounds();
							self.map.fitBounds(bounds)
						}
						self.lyr[id].remove()
					},
					changeLayers(id, e) {
						var self = this;
						if (e.target.checked) {
							self.addLayer(id, e)
						} else {
							self.removeLayer(id, e)
						}
					},
					changeAttribute(id, e) {
						var self = this;
						var ind = null;
						var key = e.target.value;
						var thisLayer = self.doc.properties.layers.forEach(function(item, i){
							if (ind) return;
							if (item.lid === id) {
								ind = i;
								self.doc.properties.layers[ind].key = key
							} 
						});
					},
					setXmlId(e){
						var self = this;
						var ind = parseInt(e.target.value, 10);
						self.newDoc.xmlid = self.gpo.packages[ind].packageId;
						self.newDoc.chind = (parseInt(self.gpo.packages[ind].congress, 10) - 1);
						self.newDoc.chtitle = self.gpo.packages[ind].title;
						//- console.log(self.newDoc)
					},
					filterGpo(e) {
						var self = this;
						if (e.target.value === '') {
							return self.getGpo();
						}
						var gpo = self.gpo.packages;
						gpo = gpo.filter(function(g){
							return new RegExp(e.target.value).test(g.title)
						})
						//- console.log(gpo)
						if (gpo && gpo.length > 0) {
							self.gpo.packages = gpo;
						}
					},
					changeDocType(e) {
						e.preventDefault()
						
						var self = this;
						//- console.log(e.target.value)
						var ind = parseInt(e.target.value, 10);
						self.newDoc.tiind = ind;
					},
					changePlaceType(e) {
						e.preventDefault()
						var self = this;
						var url;
						if (self.placetypes && self.placetypes.length > 0) {
							url = self.placetypes.filter(function(pt){
								if (pt && pt.name) {
									return pt.name === e.target.value;
								} else {
									return false;
								}
								
							});
						} 
						if (url[0]) {
							url = url[0].url;
							var type = 
								e.target.value
							$.getJSON(url).then(async function(json){
								await console.log(json)
								self.newDoc.placetype = type;
								self.newDoc.tempGeo = await json.features;
								if (type === 'Nation' && self.newDoc.tiind === 0) {
									self.newDoc.tempGeo = [self.newDoc.tempGeo[0]];
									self.getGpo();
								}
								console.log(self.newDoc.tempGeo)
							})
							.catch((err)=>console.log(err))
						}
						
					},
					changePlaceNew(e) {
						e.preventDefault()
						var self = this;
						//- console.log(e.target.value)
						var ind = parseInt(e.target.value, 10);
						//- console.log(ind)
						self.newDoc.place = (isNaN(ind) || !self.newDoc.tempGeo[ind] ? (!self.newDoc.tempGeo[self.newDoc.tempGeo.length-1] ? null : self.newDoc.tempGeo.length-1) : ind )
					},
					submitZip(e) {
						var self = this;
						$.post('/pu/getgeo/'+null+'/'+null+'/'+self.modal.zip+'')
						.then(function(href){
							window.location.href = href
						})
					},
					handleLocationOutcome(geolocation, pos) {
						var self = this;
						//- console.log(geolocation)
						var modal = document.getElementById('modal');
						if (!geolocation && modal) {
							self.modal.msg = 'geolocator didn\'t work. Please provide the zip code you vote from. ';
							self.modal.id = 'zip'
						} else if (geolocation) {
							if (!pos || !pos.lat) {
								
							} else {
								$.post('/pu/getgeo/'+pos.lat+'/'+pos.lng+'/'+null+'')
								.then(function(href){
									window.location.href = href
								})
							}
							
						} else {
							if (!self.pu || !self.pu._id){
								
							}else {
								window.location.href = '/pu/getgeo/'+self.pu._id+''
							}
						}
					},
					changeDiff(e) {
						var self = this;
						//- console.log(e.target.value)
						self.dfi = (!isNaN(parseInt(e.target.value, 10)) ? parseInt(e.target.value, 10) : null);
					},
					navigateTo: function(url){
						window.location.href = url;
					},
					deleteEntry(doc, e) {
						e.preventDefault()
						//- console.log(doc)
						$.post('/api/deleteentry/'+doc._id+'').then(function(res){
							//- console.log(res)
							window.location.href = '/menu/'+doc.properties.title.ind+'/'+doc.properties.chapter.ind+'';
						})
						.catch(function(err){
							console.log(err)
						})
					},
					deleteMedia: function(ind) {
						var self = this;
						$.post('/api/deletemedia/'+self.doc._id+'/'+ind+'', function(res){
							self.doc = res;
						})
					},
					accordion(n, ind, e) {
						var self = this;
						if (e) e.preventDefault();
						if (!ind) {
							if (!self.accordions[n].length) {
								if (!self.dat || self.dat === '') {
								} else {
									self.dat.forEach(async function(datas, i){
										if (i === n) {
											self.accordions[n] = await datas.map(function(doc){return doc.index})
										}
									});
									
								}
								self.accordions[n].sort();
							} else {
								var sac = self.accordions;
								if (sac) {
									while(sac[n].length > 0) {sac[n].pop();}
									self.accordions = sac;
								}
								
							}
						} else {
							if (self.accordions[n].indexOf(ind) === -1) {
								self.accordions[n].push(ind);
								self.accordions[n].sort();
							} else {
								self.accordions[n].splice(self.accordions[n].indexOf(ind), 1);
							}
						}
					},
					toggleExport: function() {
						this.export = !this.export;
					},
					getHTML: function(type, str) {
						var self = this;
						var span = document.createElement(type);
						span.innerHTML = str;
						return span.outerHTML;
					},

					dPathAttr: function() {
						var self = this;
						var thickness = (!thickness ? 50 : thickness);
						var nw = (!self.wWidth ? window.innerWidth : self.wWidth);
						var nh = (!self.wHeight ? window.innerHeight : self.wHeight);
						var d;
						if (self.type === 'draw') {
							d = "M0,0v"+nh+"h"+nw+"V0H0L0,0z"
						} else {
							d = "M0,0v"+nh+"h"+nw+"V0H0L0,0z "+
							"M"+(thickness)+","+(thickness)+"H"+(nw - thickness)+"V"+(nh - thickness)+"H"+(thickness)+"V"+(thickness)+"z "
						}
						return d;
					},
					
					panZoom: function(){
						var self = this;
						//console.log(self.map)
						if (self.map && self.latlng) {
							$.post('/panzoom/'+self.latlng.lat+'/'+self.latlng.lng+'/'+self.map.getZoom()+'', function(result){
							})
						}
						
					},
					toggleEdit: function(ind) {
						var self = this;
						this.edit = (!this.edit ? ind : null);
					},
					checkNameValidity(type, aSearchTerm, aMsg, event) {
						var self = this;
						var elem = event.target;//document.getElementById(aID);
						for (var i = 0; i < elem.value.length; i++) {
							if (aSearchTerm.indexOf(elem.value.charAt(i)) !== -1) {
								elem.setAttribute("aria-invalid", "true");
							} else {
								elem.setAttribute("aria-invalid", "false");
							}
						}
						var check = elem.value;
						if (check !== '' && type === 'givenName') {
							var url = check.replace(' ', '_');
							$.post('/check/'+check).done(function(result, res){
								//- console.log(result, res)
								self.avail = (result === 'Available')
							})
						}
					},
					initSig() {
						var self = this;
						self.type = 'draw';
						document.getElementById('viewer').scrollIntoView();

					},
					setSigData(i, val, ts, can) {
						var self = this;
						
						Vue.set(self.can, parseInt(i,10), can)
						//- console.log(self.ts, ts)
						if (!Array.isArray(self.ts)) {
							self.ts = [];
						}
						Vue.set(self.ts, 0, ts)
					},
					updateSignature(index, url) {
						Vue.set(this.signatureDataUris, 0, url);
					},
					signatureToBlob(cb) {
						var self = this;
						if (!HTMLCanvasElement.prototype.toBlob) {
						 Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
							value: function (callback, type, quality) {
								var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
								len = binStr.length,
								arr = new Uint8Array(len);
								for (var i = 0; i < len; i++ ) {
									arr[i] = binStr.charCodeAt(i);
								}
								callback( new Blob( [arr], {type: type || 'image/png'} ) );
							}
						 });
						}
						self.can[0].toBlob(function(blob){
							cb(blob);
						}, 'image/png')
					},
					saveSignature(){
						var self = this;
						var fd = new FormData();
						self.signatureToBlob(function(blob){
							
							fd.append('img', blob);
							fd.append('_csrf', '#{csrfToken}');
							fd.append('ts', self.ts);

							var uploadurl = '/sig/uploadsignature/'+self.doc._id+'/'+self.pu._id+'';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
								success: function(response) {
									self.mode = 'blog';
									window.location.href = response
								}
							})
						})
					},
					activateMap(){
						var self = this;
						var mapActive = self.mapActive;
						var mapEdit = self.mapEdit;
						if (!mapActive) {
							if (self.loggedin && self.loggedin !== '' && self.pu && self.pu !== '' && self.pu.properties.admin && self.dataLayer._latlngs && self.dataLayer._latlngs.length < 2) {
								//- self.dataLayer.enableEdit();
								self.mapEdit = !mapEdit;
							}
							document.getElementById('viewer').scrollIntoView();
							$('.submenu.drop').slideUp(100);
							$('.slidedown').slideUp(100);

							//- tinymce.get('description').hide();
						} else {
							if (self.loggedin && self.loggedin !== '' && self.pu && self.pu !== '' && self.pu.properties.admin && typeof self.dataLayer.disableEdit === 'function') {
								self.dataLayer.disableEdit();
								self.mapEdit = !mapEdit;
							}

							document.getElementById('inputs').scrollIntoView();
							//- tinymce.get('description').show();

						}
						self.mapActive = !mapActive;
						if (self.mapActive && !self.mapReady) {
							self.mapReady = true;
						}
						if (self.mapActive) {
							$('.slidedown').slideUp(100);

						}
					},
					
					addMapBlob() {
						var self = this;
						var ind = self.doc.properties.media.length;
						var mapActive = self.mapActive;
						self.mapActive = !mapActive;
						document.getElementById('inputs').scrollIntoView();

						if (typeof self.dataLayer.disableEdit === 'function'){
							self.dataLayer.disableEdit();
							self.mapEdit = false;
						}
						self.addNewMedia(self.doc._id, ind, function(){
							leafletImage(self.map, function(err, canvas){
								if (err) {
									return console.log(err)
								}
								$('a[id*=deletemedia]').hide();
								var im = new Image()
								im.src = canvas.toDataURL('image/png');
								im.onload = function(){
									self.checkImage(im, canvas, im.width, im.height, 1025, 1025, ind, 'map');
									setTimeout(function(){
										var img = document.querySelector('img#return'+ind+'');
										var can = $('#canvas'+ind+'')[0];
										var w = img.width;
										var h = img.height;
										can.width = w;
										can.height = h;
										var ctx = can.getContext("2d");
										ctx.drawImage(img, 0, 0, w, h);
										self.uploadBlob(img, can, ind, function(){
											var dataurl = can.toDataURL("image/png", 0.8);
											self.doc.properties.media[ind].thumb = dataurl.replace(/data:image\/png;base64,/, '');
										})
									},2000)
								}
							})
						});
					},
					addNewMedia: function(id, index, cb) {
						var self = this;
						$.post('/api/newmedia/'+id+'/'+index+'', function(res) {
							self.doc.properties.media.push(res);
							cb()
						})
					},
					handleFile: function(did, index) {
						var self = this;
						self.did = did;
						self.file = document.getElementById('media_'+index).files[0];
						self.processImage(index);
					},
					processJson(){
						var self = this;
						var dataurl = null;
						var file = self.file;
						if (!file) return;
						//- console.log(file)
						// TODO validate json type somehow before upload
						var reader = new FileReader();
						reader.onloadend = function(e) {
						//- reader.addEventListener("load", function () {
							var fd = new FormData();
							var blob = this.result;
							//- console.log(blob)
							fd.append("json", file);
							fd.append('_csrf', '#{csrfToken}');

							var uploadurl = '/api/importjson/'+self.doc._id+'/json';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
									success: function(response) { 
										self.doc = response
										console.log(response)
										
									}
								})
						}
						//- }, false)
						reader.readAsDataURL(file);
						
					},
					processImage: function(imgindex) {
						var self = this;
						var dataurl = null;
						var file = self.file;
						if (!file) return;
						var imagefile = file.type;
						var imageTypes= ["image/jpeg","image/png","image/jpg","image/svg+xml"];
						if(imageTypes.indexOf(imagefile) === -1) {
							$("#info").html("<span class='msg-error'>Please Select A valid Image File</span><br /><span>Only jpeg, jpg, png, and pdf types allowed</span>");
							return false;
							
						} else {
							var reader = new FileReader();
							
							reader.onloadend = function(e) {
								var img = document.getElementById('return'+imgindex+'');
								img.src = e.target.result;
								var type = imagefile.split('image/')[1];
								img.onload = function() {
									$('#media').val('');
									var can = $('#canvas'+imgindex+'')[0];
									var maxWidth = 1025 ;
									var maxHeight = 1025 ;
									var w = img.width;
									var h = img.height;
									can.width = w;
									can.height = h;
									var ctx = can.getContext("2d");
									ctx.drawImage(img, 0, 0);
									self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, type);
								}
								
							}
							reader.readAsDataURL(file);
						}
					},
					checkImage: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype) {
						var self = this;
						if (h > maxHeight || w > maxWidth) {
							self.reSize(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
						} else {
							if (imgtype === 'map') {
								var im = document.querySelector('img#return'+imgindex+'');
								im.setAttribute('src', can.toDataURL('image/png'))
							} else {
								if (maxHeight === 400) {
									self.drawThumb(img, can, w, h, imgindex, imgtype)
								} else {
									self.drawFull(img, can, w, h, imgindex, imgtype)
								}
							}
						}
						
					},
					reSize: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype){
						can.height = h*0.99;
						can.width = w*0.99;

						var can2 = document.createElement('canvas');
						can2.width = w*0.99;
						can2.height = h*0.99;
						var ctx2 = can2.getContext('2d');
						var ctx = can.getContext('2d');
						ctx2.drawImage(img, 0, 0, w*0.99, h*0.99);
						ctx.drawImage(can2, 0, 0, w*0.99, h*0.99, 0, 0, w*0.99, h*0.99);
						w = w*0.99;
						h = h*0.99;
						img.width = w;
						img.height = h;
						this.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
					},
					uploadBlob: function(img, can, imgindex, cb) {
						var self = this;
						var orientation = 'portrait'
						if (can.width > can.height) { 
							orientation = 'landscape' 
						} else { 
							orientation = 'portrait' 
						}

						if (!HTMLCanvasElement.prototype.toBlob) {
						 Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
							value: function (callback, type, quality) {
								var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
								len = binStr.length,
								arr = new Uint8Array(len);
								for (var i = 0; i < len; i++ ) {
									arr[i] = binStr.charCodeAt(i);
								}
								callback( new Blob( [arr], {type: type || 'image/png'} ) );
							}
						 });
						}
						can.toBlob(function(blob) {
							var fd = new FormData();
							fd.append("img", blob);
							var uploadurl = '/api/uploadmedia/'+self.doc.index+'/'+imgindex+'/png';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
									success: function(response) { 
									img.onload = function () {
										self.doc.properties.media[imgindex].image_abs = response;
										self.doc.properties.media[imgindex].image = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].thumb_abs = response;
										self.doc.properties.media[imgindex].thumb = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].orientation = orientation;
										cb();
									}
									img.src = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
								}
							})
						}, 'image/png');
					},
					drawFull: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
					// console.log(w,h)
						ctx.drawImage(img, 0, 0, w, h);
						self.uploadBlob(img, can, imgindex, function(){
							var can = $('#canvas'+imgindex+'')[0];
							var maxWidth = 250 ;
							var maxHeight = 250 ;
							var w = img.width;
							var h = img.height;

							self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype);
						})
						
					},
					drawThumb: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
						
						ctx.drawImage(img, 0, 0, w, h);
						var dataurl = can.toDataURL("image/png", 0.78);
						setTimeout(function(){
							self.doc.properties.media[imgindex].thumb = dataurl.replace(/data:image\/png;base64,/, '');
							//$('#inputthumb'+imgindex+'').val(dataurl.replace(/data:image\/png;base64,/, ''));
							
						}, 100);
					},
					handleGeoJson(e){
						var self = this;
						self.file = 
							//document.getElementById('lyr_'+doc._id)
							e.target.files[0];
						self.processJson()
					},
					getLayers(id) {
						//- self.lyr[item._id]
						var self = this;
						$.get('/api/geointersect/'+id+'', function(res){
							if (res.length === 1 && res[0]._id === self.doc._id) {
								$.get('/')
							}
							console.log(res)
						})
					},
					styleOf(feature, type) {
						var self = this;
						var keys = self.doc.properties.layers.map(function(item){return item.lid})
						var cind = keys.indexOf(feature._id);
						var c = (!self.c[cind] ? 'var(--highlight)' : self.c[cind]);
						var style = {
												fillColor: c,
												color: c,
												weight: 2,
												opacity: 1,
												fillOpacity: 0.8,
												className: feature._id
												
												}
						switch(type){
							case 'MultiPoint':
								style.radius = 10;
								style.color = '#fff';
								style.fillColor = c;
								break;
							case 'Point':
								style.radius = 10;
								style.color = '#fff';
								style.fillColor = c;
								break;
							case 'Polygon':
								break;
							case 'MultiPolygon':
								break;
							default: 
						}
						return style;
					},
					coordsToLatLng(coords) { // (Array[, Boolean]) -> LatLng
						return new L.LatLng(coords[1], coords[0]);
					},
					coordsToLatLngs(coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
						var latlng, i, len,
								latlngs = [];
						for (i = 0, len = coords.length; i < len; i++) {
							latlng = levelsDeep ?
								this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
								(coordsToLatLng || this.coordsToLatLng)(coords[i]);
							latlngs.push(latlng);
						}
						return latlngs;
					},
					isPointCoords(ll) {
						if (ll.length === 2 || ll.length === 3 && !Array.isArray(ll[0])) {
							return true
						} else 
						if (ll[0][0] && ll[0].length === 2 && !Array.isArray(ll[0][0])) {
							return true
						} else if (ll[0][0][0] && ll[0][0].length === 2 && !Array.isArray(ll[0][0][0])) {
							return true
						} else {
							return false;
						}
					},
					isPointLatlng(ll) {
						if (!Number.isNaN(parseInt(ll.lat, 10))) {
							return true
						} else {
							return false
						} 
					},
					async filterViewerList(ll1, ll2, feature, keys, vals, buf) {
						var self = this;
						var latlng = ll2;
						//- $.get('/publishers/esta/json/json_'+feature._id+'.json')
						//- .then(async function(json){
						//- 	if (json.features){
						if (self.json[feature._id]) {
							var counter = 0;
							self.geo = (!self.json[feature._id].features ? [self.json[feature._id]] : await self.json[feature._id].features
							.filter(function(ft, j){
								if (self.isPointCoords(ft.geometry.coordinates)) {
									//TODO: Add as layer, then get bounds, then get center
									var rx = ft.geometry.coordinates.reverse();
									var center = L.latLng(rx) 
									latlng = center;
									return ll1.contains(center);
								} else {
									var bf = L.geoJSON(ft, {
										style: function (feature) {
											return {color: 'tomato'};
										}
									}).addTo(self.map);
									var l1 = bf.getBounds();
									var contains = (l1.contains(latlng));
									if (contains) {
										ll1 = l1
										self.buf[counter] = bf;
										counter++
									} else {
										bf.remove()
									}
									return contains;
								}
							}))
							if (self.geo && self.geo.length > 0) {
								//- console.log(self.geo)
								if (ll1._southWest) {
									self.map.fitBounds(ll1);
									var mark = L.latLngBounds(ll1).getCenter();
									self.map.panTo(mark);
									self.lMarker.setLatLng(mark);
								} else {
									self.map.panTo(latlng);
									self.lMarker.setLatLng(latlng);
								}
								//- 
								if (self.geo.length > 0) {
									self.viewerList = true;
								} else {
									self.viewerList = false;
								}
							} else {
								console.log('wtaf')
								//- buf.remove();

							}
						}
						
						buf.remove();

						//- })
						//- .catch(function(err){
						//- 	console.log(err)
						//- })
					},
					getAttributes(feature) {
						var self = this;
						var vals = self.lyr[feature._id]
						$.get('/publishers/esta/json/json_'+feature._id+'.json')
						.then(async function(json){
							if (json.features){
								return Object.keys(json.features[0])
							}
						})
					},
					//- arrayEqArray(arr1, arr2)
					setView(feature, latlng){
						var self = this;
						if (self.buf) self.buf.remove()
						//- self.viewerList = true;
						self.geo = [feature]
						self.buf = L.geoJSON(feature, {
							style: function (feature) {
								return {color: 'tomato'};
							}
						}).addTo(self.map);
						var l1 = self.buf.getBounds();
						var c = l1.getCenter();
						self.map.fitBounds(l1)
						self.lMarker.setLatLng(c);
						self.lMarker.setOpacity(1);
						self.btn.x = (self.wWidth/2);
						self.btn.y = (self.wHeight/2);
						self.viewerList = true;
						//- if (self.buf && self.buf.length > 0) {
						//- 	self.buf.forEach(function(item){
						//- 		item.remove();
						//- 	})
						//- }
						//- self.cZF = (self.map.getZoom() + self.zfactor);
						//- var cp = self.map.latLngToLayerPoint(latlng);
						//- var x1 = cp.x-10;
						//- var y1 = cp.y-10;
						//- var x2 = cp.x+10;
						//- var y2 = cp.y+10;
						//- var p1 = self.map.layerPointToLatLng(L.point(x1,y1));
						//- var p2 = self.map.layerPointToLatLng(L.point(x2, y2));
						//- 
						//- var buf = L.featureGroup([L.circle(p1), L.circle(p2)]).addTo(self.map);
						//- var ll1 = buf.getBounds();
						//- var ll2 = latlng;
						//- var keys;
						//- var vals;
						//- if (!self.dataLayer._layers && self.lyr[feature._id]) {
						//- 	if (!self.lyr[feature._id]._layers) {
						//- 		keys = Array.from(Array(self.lyr[feature._id]._latlngs.length).keys())
						//- 	} else {
						//- 		keys = Object.keys(self.lyr[feature._id]._layers)
						//- 	}
						//- 	vals = self.lyr[feature._id];
						//- 	//- console.log(feature, vals)
						//- } else {
						//- 	vals = self.dataLayer;
						//- 	keys = (!vals || !vals._layers ? Array.from(Array(self.dataLayer._latlngs.length).keys()) : Object.keys(vals._layers));
						//- 	//- console.log(keys)
						//- }
						//- self.filterViewerList(ll1, ll2, feature, keys, vals, buf)
						
						
					},
					onEachFeaturePoly(id,feature,layer){
						
					},
					onEachFeaturePoint(id, feature,layer){
						//- var thisLayer = L.GeoJSON.geometryToLayer(feature, {
						//- 	pointToLayer: function(ft, latlng) {
						//- 		var circle = new L.CircleMarker(latlng)//, self.styleOf(ft, ft.geometry.type))
						//- 			.on('click', function(){
						//- 				return self.setView(ft, latlng)
						//- 			});
						//- 		return circle;
						//- 	}
						//- 
						//- });
						//- colors.forEach(function(color, i){
						//- 	var mi = inc * i;
						//- 	var ma = (!colors[i+1] ? max : (inc * i+1));
						//- 	//- console.log(feature.properties[thisKey], mi, ma)
						//- 	if (feature.properties[thisKey] >= mi && feature.properties[thisKey] < ma) {
						//- 		thisLayer.setStyle({fillColor:color, color:color})
						//- 	}
						//- })
						//- thisLayer.on('click', function(e){
						//- 	self.setView(feature, e.latlng)
						//- })
						//- ljson.addLayer(thisLayer)
					},
					loadLayer(item, id) {
						var self = this;
						var ljson;
						if (self.lyr[id] && typeof self.lyr[id].clearLayers === 'function') {
							self.lyr[id].clearLayers();
						}
						var ind = null;
						var style = (!id ? {buckets:1,colors:['#fff']} : self.doc.properties.layers
						.map(function(item, i){
							if (item.lid === id) {
								ind = i;
							}
							return item;
						}).filter(function(item){
							
							return item.lid === id
						})[0]);
						if (item.features && item.features[0]) {
							
						
							//- var colors = ['red','yellow','blue'];
							var colors = style.colors;
							var theseKeys = Object.keys(item.features[0].properties).filter(function(it){return !isNaN(parseInt(item.features[0].properties[it], 10))})
							var thisKey = (!style.key || style.key === "" ? theseKeys[theseKeys.length-1] : style.key);
							var vals = item.features.map(function(feature){
								return (!isNaN(parseInt(feature.properties[thisKey],10)) ? feature.properties[thisKey] : null) 
								//- return parseFloat(feature.properties[thisKey]
								})
							var min = Math.min.apply(null,vals);
							var max = Math.max.apply(null,vals);
							var range = max - min;
							var inc = range / colors.length;
							style.min = min;
							style.max = max;
							style.inc = inc;
							if (ind) {
								self.doc.properties.layers[ind] = style;
							}
							ljson = L.geoJson().addTo(self.map);
							//- console.log(thisKey,min,max,inc,colors)
							var isPointCoords = (!item.features ? self.isPointCoords(item.geometry.coordinates) : self.isPointCoords(item.features[0].geometry.coordinates))
							if (isPointCoords) {
								//- console.log('is point')
								var ojson = L.geoJson(item, {
									
									onEachFeature:function(feature,layer){
										var thisLayer = L.GeoJSON.geometryToLayer(feature, {
											pointToLayer: function(ft, latlng) {
												var thisVal = ft.properties[thisKey]//parseFloat(feature.properties[thisKey])
												var cls = []
												var cl = colors.forEach(function(color,i){
													var mi = min;
													var ma = (!colors[i+1] ? max : (inc * i+1));
													if (thisVal >= mi && thisVal <= ma) {
														cls.push(color)
													}
												})
												var style = {fillColor:cls[0], color:cls[0], opacity: 0.8, fillOpacity: 0.6, radius: 8}
												var circle = new L.CircleMarker(latlng, style)//, self.styleOf(ft, ft.geometry.type))
													.on('click', function(){
														return self.setView(ft, latlng)
													});
												return circle;
											}

										});
										thisLayer.on('click', function(e){
											self.setView(feature, e.latlng)
										})
										ljson.addLayer(thisLayer)
									}
								})
							} else {

								var ojson = L.geoJson(item, {
									
									onEachFeature:function(feature,layer){
										var thisLayer = L.GeoJSON.geometryToLayer(feature);
										thisLayer.setStyle({fillColor:'#fff',color:'#fff', weight:1, opacity: 0.3, fillOpacity: 0.2})
										colors.forEach(function(color, i){
											var mi = inc * i;
											var ma = (!colors[i+1] ? max : (inc * i+1));
											var thisVal = parseFloat(feature.properties[thisKey])
											if (thisVal >= mi && thisVal < ma) {
												thisLayer.setStyle({fillColor:color, color:color, opacity: 0.8, fillOpacity: 0.6})
											}
										})
										thisLayer.on('click', function(e){
											self.setView(feature, e.latlng)
										})
										ljson.addLayer(thisLayer)
									}
								})
							}
						} 
						else {
							var isPointCoords = (!item.features || !item.features[0] ? self.isPointCoords(item.geometry.coordinates) : self.isPointCoords(item.features[0].geometry.coordinates))
							if (isPointCoords) {
								ljson = L.GeoJSON.geometryToLayer(item, {
									style: function(feature) {
										return self.styleOf(feature, feature.geometry.type)
									},
									pointToLayer: function(feature, latlng) {
										var circle = new L.CircleMarker(latlng, self.styleOf(feature, feature.geometry.type))
											.on('click', function(){
												return self.setView(feature, latlng)
											});
										return circle;
									}
								})
						
							} else {
								//- console.log('wtaff?')
								ljson = L.GeoJSON.geometryToLayer(item)
							}
						
						}
						return ljson;
						
					},
					layerToDataLayer(dataLayer) {
						var self = this;
						var keys = Object.keys(dataLayer._layers)
						self.latlngs = [keys.map(function(key){
							if (dataLayer._layers[parseInt(key, 10)]._latlng) {
								return L.latLng([dataLayer._layers[parseInt(key, 10)]._latlng.lat, dataLayer._layers[parseInt(key, 10)]._latlng.lng])//.wrap();
							} else {
								//- console.log('bleh')
								//- console.log(dataLayer._layers[parseInt(key, 10)]);

							}
						})]
					},
					getEvictionLab() {
						$.post('/utahcourts')
						.then((result)=>{
							console.log(result);
						})
						.catch((err)=>console.log(err))
					},
					async changeCensusJurisdiction(e){
						var self = this;
						if (self.censusLoad) {
							self.censusLoad.placetype = e.target.value;
							$.post('/censusload/'+self.censusLoad.placetype)
							.then(async function(result){
								//- console.log(JSON.parse(result).layers[0].fields)
								console.log(result)
								var variables = JSON.parse(result).variables
								var keys = Object.keys(variables)
								self.censusLoad.cats = 
								//- await JSON.parse(result).layers[0].fields.map(function(field){
								//- 	return field.name;
								//- })
								keys//- keys.map(function(k){
								//- 	return variables[k].concept
								//- })
								//- Object.keys(JSON.parse(result).layers[0].fields)
								//- JSON.parse(result).variables.map(function(fd){
								//- 	return fd.concept;
								//- })
							})
							.catch(function(err){
								console.log(err)
							})
						}
					},
					async changeCensusData(e){
						var self = this;
						//- self.map.removeLayer(self.censusLayer);
						var code = e.target.value;
						var keys = Object.keys(self.lyr);
						var filterkeys = keys.filter(function(lr){
							return !isNaN(parseInt(lr, 10))
						})
						filterkeys.forEach(function(lr){
							return self.map.removeLayer(self.lyr[lr])
						})
						self.placetypes.forEach(function(bound){
							if (self.lyr[bound.ind]) {
								self.map.removeLayer(self.lyr[bound.ind])
							}
						})
						if (!code) {
							self.censusLoad.placetype = null;
						}
						else if (!self.lyr[code]) {
							
							var hoverStyle = {
							"fillOpacity": 0.5
							};
							var mapBounds = self.map.getBounds();
							//- var crs = self.map.options.crs;
							//- var nwLatLng = mapBounds.getNorthWest();
							//- var seLatLng = mapBounds.getSouthEast();
							//- var topLeft = self.map.latLngToLayerPoint(nwLatLng);
							//- var bottomRight = self.map.latLngToLayerPoint(seLatLng);
							//- $.post('/censusload/'+)
							$.post('/census/'+self.censusLoad.placetype+'/'+encodeURIComponent(self.censusLoad.cat)+'')//+tableid+'/'+state+'')
							.then(function(result){
								//- console.log(JSON.parse(result))
								self.censusData = JSON.parse(result).features;
								var colors = self.c;//['tomato', '#191970', '#F5FFFA', '#1E90FF', '#ADFF2F', '#FF7F50']
								
								self.censusData.forEach(async function(item, i){
									var pop = item.attributes.POP100;
									var color = (
										pop < 5000 ? colors[0] :
										(
											pop >= 5000 && pop < 10000 ? colors[1] :
											(
												pop >= 10000 && pop < 25000 ? colors[2] :
												(
													pop >= 25000 && pop < 50000 ? colors[3] :
													(
														pop >= 50000 ? colors[4] : '#ffffff'
													)
												)
											)
										)
									);
									var style = {
									"clickable": true,
									"color": "#00D",
									"fillColor": color,//colors[i],
									"weight": 1.0,
									"opacity": 0.3,
									"fillOpacity": 0.2
									};
									//- console.log(item)
									var it = {geometry: {}, properties:{}};
									it.geometry.coordinates = [item.geometry.rings];
									it.geometry.type = 'MultiPolygon';
									it.properties = item.attributes;
									it.properties.name = item.attributes.name;
									it.type = 'Feature';
									//- console.log(it)
									if (it.geometry.coordinates) {
										
										self.lyr[code] = self.loadLayer(it);
										self.lyr[code].setStyle(style)
										//- await self.map.addLayer(self.lyr[code]);
										var bounds = self.lyr[code].getBounds();
										self.map.fitBounds(bounds);
										//- self.lyr[item.attributes.OBJECTID].remove()
									}
								})
							})
							.catch(function(err){
								console.log(err)
							})							
						} else {
							self.boundary = code;
							self.map.addLayer(self.lyr[code]);
							var bounds = self.lyr[code].getBounds();
							self.map.fitBounds(bounds);
						}
					},
					async changeCensus(e){
						var self = this;
						//- self.map.removeLayer(self.censusLayer);
						var code = e.target.value;
						var keys = Object.keys(self.lyr);
						var filterkeys = keys.filter(function(lr){
							return !isNaN(parseInt(lr, 10))
						})
						filterkeys.forEach(function(lr){
							return self.map.removeLayer(self.lyr[lr])
						})
						self.boundaries.forEach(function(bound){
							if (self.lyr[bound.code]) {
								self.map.removeLayer(self.lyr[bound.code])
							}
						})
						if (!code) {
							self.boundary = null;
						}
						else if (!self.lyr[code]) {
							var style = {
							"clickable": true,
							"color": "#00D",
							"fillColor": "#00D",
							"weight": 1.0,
							"opacity": 0.3,
							"fillOpacity": 0.2
							};
							var hoverStyle = {
							"fillOpacity": 0.5
							};
							var mapBounds = self.map.getBounds();
							var crs = self.map.options.crs;
							var nwLatLng = mapBounds.getNorthWest();
							var seLatLng = mapBounds.getSouthEast();
							var topLeft = self.map.latLngToLayerPoint(nwLatLng);
							var bottomRight = self.map.latLngToLayerPoint(seLatLng);
							$.post('/census/'+code+'/')//+tableid+'/'+state+'')
							.then(function(result){
								//- console.log(JSON.parse(result))
								self.censusData = JSON.parse(result).results;
								var colors = self.c;//['tomato', '#191970', '#F5FFFA', '#1E90FF', '#ADFF2F', '#FF7F50']

								self.censusData.forEach(async function(item, i){
									console.log(item)
									var it = {geometry: {}, properties:{}};
									it.geometry.coordinates = [item.geometry.rings];
									it.geometry.type = 'MultiPolygon';
									it.properties = item.attributes;
									it.properties.name = item.attributes.name;
									it.type = 'Feature';
									console.log(it)
									if (it.geometry.coordinates) {
										
										self.lyr[item.attributes.OBJECTID] = self.loadLayer(it);
										self.lyr[item.attributes.OBJECTID].setStyle({fillColor: self.c[i]})
										//- await self.map.addLayer(self.lyr[item.attributes.OBJECTID]);
										//- self.lyr[item.attributes.OBJECTID].remove()
									}
								})
							})
							.catch(function(err){
								console.log(err)
							})							
						} else {
							self.boundary = code;
							self.map.addLayer(self.lyr[code]);
							var bounds = self.lyr[code].getBounds();
							self.map.fitBounds(bounds);
						}
						
					},
					numberColorBucket(lid, e) {
						var self = this;
						if (self.colorTimeout) clearTimeout(self.colorTimeout);
						self.colorTimeout = setTimeout(function(){
							var length = parseInt(e.target.value,10);
							self.doc.properties.layers.forEach(function(item, j){
								if (item.lid === lid) {
									//- console.log(self.doc.properties.layers[j].colors.length, length)
									if (self.doc.properties.layers[j].colors.length < length) {
										var diff = length - self.doc.properties.layers[j].colors.length;
										for (var i = 0; i < diff; i++) {
											self.doc.properties.layers[j].colors.push('#000000')
										}
									} else {
										var diff = self.doc.properties.layers[j].colors.length - length;
										self.doc.properties.layers[j].colors.splice(length-1, diff)
									}
									self.lyr[lid] = self.loadLayer(self.json[lid], lid)
									//- self.doc.properties.layers[j].colors[index] = e.target.value
								}
							});
						},500)
						
					},
					changeColorBucket(i, index, e) {
						var self = this;
						if (self.colorTimeout) clearTimeout(self.colorTimeout);
						self.colorTimeout = setTimeout(function(){
							//- console.log('ok')
							//- const thisLayer = self.doc.properties.layers.filter(function(item){
							//- 	return item.lid === lid
							//- })[0];
							//- if (thisLayer) {
								self.doc.properties.layers[i].colors[index] = e.target.value;
								self.lyr[self.doc.properties.layers[i].lid] = self.loadLayer(self.json[self.doc.properties.layers[i].lid], self.doc.properties.layers[i].lid)
							//- }
							//- self.doc.properties.layers.forEach(function(item, j){
							//- 	//- console.log(item, lid, index, e.target.value)
							//- 	if (item.lid === lid) {
							//- 		//- console.log(lid, index, e)
							//- 		//self.doc.properties.layers[j]
							//- 		item.colors[index] = e.target.value;
							//- 		self.lyr[lid] = self.loadLayer(self.json[lid], lid)
							//- 
							//- 	}
							//- });
						},500)
						
						
					},
					serverJson(isDataLayer, key, cb) {
						var self = this;
						var latlng;
						var customIcon = L.icon({
							iconUrl: '/images/buttonmarker.svg',
							iconSize: [33, 33]
						});
						$.get('/publishers/esta/json/json_'+key+'.json').then(async function(result){
							if (result) {
								var isPointCoords = (!result.features ? self.isPointCoords(result.geometry.coordinates) : self.isPointCoords(result.features[0].geometry.coordinates))
								if (isDataLayer) {
									self.dataLayer = await self.loadLayer(result);
									self.map.addLayer(self.dataLayer);
									if (self.dataLayer && typeof self.dataLayer.bringToBack === 'function') self.dataLayer.bringToBack()

									if (!latlng) {
										latlng = self.dataLayer.getBounds().getCenter();
										self.lMarker = L.marker(latlng, {/*icon:customIcon, */draggable: true, opacity: 0}).addTo(self.map);
										self.map.panTo(latlng)

									}

								} else {
									self.json[key] = result;
									self.lyr[key] = self.loadLayer(result, key);
									if (self.lyr[key].options) self.lyr[key].options.interactive = false;

									if (isPointCoords) {
										self.lyr[key].bringToFront()
									} else {
										self.lyr[key].bringToBack()
										if (self.dataLayer && typeof self.dataLayer.bringToBack === 'function') self.dataLayer.bringToBack()
									}
									if (!latlng) {
										latlng = self.lyr[key].getBounds().getCenter();
										self.lMarker = L.marker(latlng, {/*icon:customIcon, */draggable: true, opacity: 0}).addTo(self.map);
										self.map.panTo(latlng)

									}

								}
								cb(latlng)
							}
						})
						.catch(function(err){
							if (isDataLayer) {
								self.dataLayer = self.loadLayer(self.doc);
								self.map.addLayer(self.dataLayer);
								if (self.dataLayer && typeof self.dataLayer.bringToBack === 'function') self.dataLayer.bringToBack()
								if (!latlng) {
									latlng = self.dataLayer.getBounds().getCenter();
									self.lMarker = L.marker(latlng, {/*icon:customIcon, */draggable: true, opacity: 0}).addTo(self.map);
									self.map.panTo(latlng)

								}

							} else {
								self.json[key] = item;
								self.lyr[key] = self.loadLayer(item, key);
								if (self.lyr[key].options) self.lyr[key].options.interactive = false;
								if (self.dataLayer && typeof self.dataLayer.bringToBack === 'function') self.dataLayer.bringToBack()

								if (!latlng) {
									latlng = self.lyr[key].getBounds().getCenter();
									self.lMarker = L.marker(latlng, {/*icon:customIcon, */draggable: true, opacity: 0}).addTo(self.map);
									self.map.panTo(latlng)

								}
							}
							cb(latlng)
						})
					}
					 /*Leaflet requires reversed geo-coordinate (lat, lng)*/,
					async loadMap(cb) {
						var self = this;
						var dataLayer;
						var dataCoords;
						var map = new L.map('map', { 
							center: [
								(!self.latlng ? 40.7608 : self.latlng.lng),
								(!self.latlng ? -111.8910 : self.latlng.lat)
							], 
							zoom: (!self.position ? 6 : self.position.zoom),
							zoomControl: false,
							minZoom: 2,
							maxZoom: 18,
							editable: true,
							renderer: L.canvas(),
							preferCanvas: true,
							editOptions: {
								skipMiddleMarkers: true
							}
						});
						L.control.zoom({
							position:'topleft'
						}).addTo(map);
						
						//- self.censusLayer = L.tileLayer('https://api.censusreporter.org/1.0/geo/tiger2013/tiles/040/{z}/{x}/{y}.geojson').addTo(map)
						//- self.censusLayer.bringToFront();
						var credit = (!self.credit || self.credit === '' ? self.getCredit() : self.credit) + ' | ' + self.baseMaps[self.base].attribution
						self.tilelayer = L.tileLayer(self.baseMaps[self.base].url, {renderer: L.canvas({padding:0.5}), bounds: map.getBounds().pad(1000), attribution: credit}).addTo(map);
						self.map = map;
						//- self.cZF = (18 - self.map.getZoom() + self.zfactor)
						
						var myRenderer = L.canvas({ padding: 0.5 });
						//- var latlng;
						if (self.doc && self.doc !== '') {
							// generate geographic points from data
							var key = self.doc._id;
							self.serverJson(true, key, async function(latlng){
								//- console.log(latlng)
								if (self.doc.properties && self.doc.properties.title.str !== 'Geography') {
									var keys = self.doc.properties.layers.map(async function(item){return item.lid})
									if (self.layers && self.layers.length > 0) {
										if (self.dataLayer.options) self.dataLayer.options.interactive = false;
										self.mapEdit = false;
										await self.layers.forEach(function(item){
											var key = item._id;
											self.serverJson(false, key, function(latlng){
												if (Object.keys(self.json).length >= self.layers.length) {
													self.mapReady = true;
												}
											})
										});
									}
									if (self.availablelayers && self.availablelayers.length > 0) {
										await self.availablelayers.forEach(function(item, i){
											var key = item._id;
											$.get('/publishers/esta/json/json_'+key+'.json').then(function(result){
												if (result) {
													self.json[key] = result;
													self.lyr[key] = self.loadLayer(item, key)
													if (self.lyr[key].options) self.lyr[key].options.interactive = false;
													self.lyr[key].remove()
													if (!latlng) {
														latlng = self.lyr[key].getBounds().getCenter();
													}
												}
											})
											.catch(function(err){
												self.json[key] = item;
												self.lyr[key] = self.loadLayer(item, key);
												if (self.lyr[key].options) self.lyr[key].options.interactive = false;
												self.lyr[key].remove()
												if (!latlng) {
													latlng = self.lyr[key].getBounds().getCenter();
												}
											})
										})
									}
									if (latlng) {
										cb(latlng)
									} else {
										console.log('no latlng?')
									}
								} else {
									if (latlng) {
										cb(latlng)
									} else {
										console.log('no latlng?')
									}
								}
							})
						} else {
							cb(null)
						}

						//- self.map.on('click', function(e){
						//- 	self.viewerList = false;
						//- });

						//- self.map.on('zoomstart', function(e){
						//- 	console.log(e)
						//- 	self.viewerList = false;
						//- })


							//- self.map.on('editable:vertex:rawclick', function(e){
							//- 	self.layers.forEach(function(item, i){
							//- 		if (item._id !== e.layer._id) {
							//- 			//- item.disableEdit();
							//- 		} else {
							//- 			//- item.enableEdit();
							//- 			//- self.mapEdit = true;
							//- 		}
							//- 	})
							//- })
							//- self.map.on('editable:editing', function (e) {
							//- 	e.layer.setStyle({color: 'DarkRed'});
							//- });
							//- self.map.on('editable:vertex:dragstart', async function(e){
							//- 	var cll = e.vertex.latlng.__vertex.latlng;
							//- 	var dll = self.dataLayer.getLatLngs();
							//- 	var lvl = 0;
							//- 	var p = 0;
							//- 	var dl;
							//- 	var lll = self.dataLayer.getLatLngs();
							//- 	self.latlngs = lll;
							//- })
							//- self.map.on('editable:vertex:dragend', function(e){
							//- 	console.log(e)
							//- 	var cll = e.vertex.latlng.__vertex.latlng;
							//- 	var dll = self.dataLayer.getLatLngs();
							//- 	var lvl = 0;
							//- 	var p = 0;
							//- 	var dl;
							//- 	self.latlngs = dll;
							//- 	self.doc.geometry.coordinates = self.latlngsToArr(dll, cll);
							//- })
					},
					getClip() { 
						var self = this;
						if (self.btn) {// make central clipping svg d value reactive
						var wW = ( !self.wWidth ? window.innerWidth : self.wWidth ), 
						wH = ( !self.wHeight ? window.innerHeight : self.wHeight ), 
						pW = ( !self.pWidth ? ( wW * (self.res?0.5:0.5) ) : self.pWidth ), 
						pH = ( !self.pHeight ? (wH * (self.res?0.5:0.5) ) : self.pHeight ), 
						r = self.btn.r, cRc = (r * 0.5523), cRr = 0.81, 
						sY = (isNaN(self.btn.y)?(wH*(self.res?0.5:0.5)):self.btn.y);
						var lx = self.btn.x;
						var ly = self.btn.y;
						//- var lx = self.btn.x - 1//(!min === cx ? (min + side) : cx);
						//- var ly = self.btn.y - 42//(!min === cy ? (min + side) : cy);
						//- var bez = 
						//- `M${lx},${ly}v43c10-19.3,14-21.8,14-30.2C${lx+14},${ly+6},${lx+6},${ly},${lx},${ly}z`

						var circle = 
						//- `M${wW},${wH}H0V0h${wW}V${wH}z 
						`M${lx + r},${sY}c0-${cRc}-${(cRc * cRr)}-${r}-${r}-${r}
							c-${cRc},0-${r},${(cRc * cRr)}-${r},${r} 
						c0,${cRc},${(cRc * cRr)},${r},${r},${r}
							C${lx + cRc},${(sY+r)},${lx+r},${(sY + cRc)},
							${(lx + r)},${sY}z`
						
						var str = 
						`M${wW},${wH}H0V0h${wW}V${wH}z ${circle}`
						return str; }
					},
					sliderImg(int){
						var self = this;
						//- if ($('#slider')[0]) {
						//- 	var starttime;
						//- 	self.sliderInterval = setInterval(function(){
						//- 		self.sliderOpacity = 0;
						//- 		self.sliderTimeout1 = setTimeout(function(){
						//- 			if (self.sliderIndex > 3) {
						//- 				self.sliderIndex = 1;
						//- 			} else {
						//- 				self.sliderIndex += 1;
						//- 			}
						//- 			self.sliderTimeout2 = setTimeout(function(){
						//- 				self.sliderOpacity = 1;
						//- 			},(int/5))
						//- 		},(int/5))
						//- 	}, int)
						//- 		//- requestAnimationFrame(function(ts){
						//- 		//- 	var duration = int;
						//- 		//- 	if (!starttime) {
						//- 		//- 		starttime = ts;
						//- 		//- 	}
						//- 		//- 	var timestamp = ts || new Date().getTime()
						//- 		//- 	var runtime = timestamp - starttime;
						//- 		//- 	if (runtime >= duration) {
						//- 		//- 		self.sliderOpacity = 0;
						//- 		//- 		self.sliderTimeout1 = setTimeout(function(){
						//- 		//- 			if (self.sliderIndex > 3) {
						//- 		//- 				self.sliderIndex = 1;
						//- 		//- 			} else {
						//- 		//- 				self.sliderIndex += 1;
						//- 		//- 			}
						//- 		//- 			self.sliderTimeout2 = setTimeout(function(){
						//- 		//- 				self.sliderOpacity = 1;
						//- 		//- 			},(int/5))
						//- 		//- 
						//- 		//- 		},(int/5))
						//- 		//- 	}
						//- 		//- 
						//- 		/**/
						//- 	//- }) //10000
						//- } else {
						//- 	console.log('no slider')
						//- }
					}

				}
			});

			