doctype strict
html
	head
		meta(charset="utf-8")
		meta(http-equiv="X-UA-Compatible", content="IE=edge; charset=utf-8")
		title= appTitle
		meta(name="viewport", content="width=device-width, initial-scale=1.0")
		//link(rel="stylesheet", href="/stylesheets/simplemde.min.css")
		link(rel="stylesheet", href="/stylesheets/style.css")
		link(rel="stylesheet", href="/stylesheets/leaflet.css")

		style(id="style", type="text/css")
		script(type="text/javascript", src="/scripts/vue.min.js")
		script(type="text/javascript", src="/scripts/jquery.min.js")
		script(type="text/javascript", src="/scripts/jquery-ui.min.js")
		script(type="text/javascript", src="/scripts/moment-with-locales.min.js")
		script(type="text/javascript", src="/scripts/marked.min.js")
		//script(type="text/javascript", src="/scripts/simplemde.min.js")
		script(type="text/javascript", src="https://cloud.tinymce.com/stable/tinymce.min.js?apiKey=yb2pwtctf7qznwdoo61w3kyj127j61gch5uhhzneop9mfkg7")
		script(type="text/javascript", src="/scripts/leaflet.js")
		script(type="text/javascript", src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.0.2/mocha.min.js")
		script(type='text/javascript', src='/scripts/leaflet-image_0_4_0.js')
	body
		block page
		block header
		block content
		

		script(type="text/javascript").
			
			new Vue({
				el: '#vue',
				data: function data(){
					return {
						menu: this.parseObj(!{JSON.stringify(menu)}),
						dat: this.parseObj(!{JSON.stringify(dat)}),
						data: '',//this.parseObj(!{JSON.stringify(data)}),
						doc: this.parseObj(!{JSON.stringify(doc)}),
						position: this.parseObj(!{JSON.stringify(session.position)}),
						edit: (this.parseObj(!{JSON.stringify(doc)}) === '' ? null : this.parseObj(!{JSON.stringify(doc)}).index),
						chindexes: [],
						chindex: 0,
						dindexes: [],
						dindex: (this.parseObj(!{JSON.stringify(doc)}) === '' ? 0 : this.parseObj(!{JSON.stringify(doc)}).index),
						cursor: null,
						input: '',
						fixedPug: '',
						map: '',
						dataLayer: '',
						lMarker: '',
						thickness: 45,
						wWidth: window.innerWidth,
						wHeight: window.innerHeight,
						dPath: this.dPathAttr(),
						tinymce: null,
						str: this.parseObj(!{JSON.stringify(str)}),
						diff: (!this.parseObj(!{JSON.stringify(diff)}) || this.parseObj(!{JSON.stringify(diff)}) === '' ? null : this.parseObj(!{JSON.stringify(diff)})),
						web: true,
						export: this.parseBool(!{JSON.stringify(exports)}),
						ff: this.parseObj(!{JSON.stringify(ff)}),//['General Provisions.', 'Concept Plan.', 'Sketch Plan.', 'Preliminary Subdivision Applications.', 'Final Subdivision Applications.', 'Vacating or Amending a Recorded Final Subdivision Plat, Street or Alley Final.', 'Subdivision Ordinance Amendments.', 'Noticing Requirements.', 'Appeals.', 'Special Excepetions.', 'Design and Construction Standards.', 'Guarantees for Subdivision Improvements, Facilities, and Amenities.', 'Definitions.'],
						accordions: (this.parseObj(!{JSON.stringify(dat)}) !== '' && this.parseBool(!{JSON.stringify(exports)}) ? this.parseObj(!{JSON.stringify(dat)}).map(function(data){return data.map(function(doc){return doc.index})}): [[]]),
						uploadisreplace: false,
						uploadchtitle: null
					}
				},
				updated: function(){
					if (this.dindexes.length === 0) {
						var self = this;
						self.dindexes = (self.data && self.data !== '' ? self.data.map(function(doc){
							return doc.index;
						}) : [(!self.doc || self.doc === '' ? 0 : self.doc.index)] );
						self.dindexes.sort();
					}
				},
				mounted: function(){
					console.log(this.export)
					var self = this;
					$(document).on('click', '.href', function(e){
						e.stopPropagation();
					});
					self.dindexes = (self.data && self.data !== '' ? self.data.map(function(doc){
						return doc.index;
					}) : [(!self.doc || self.doc === '' ? 0 : self.doc.index)] );
					self.dindexes.sort();
					/*if (self.export) {
						//console.log(self.diff[0].value)
						if (!self.doc || self.doc === '') {
							self.sendDiff(function(diffs){
								self.diff = diffs.dif;
							});
						} else {
						}
					} else {
						if (self.diff)
							console.log(self.diff[0].value)
					}*/
					if (self.dat) {
						self.dat.sort(function(a,b){
							return a[0].chapter.ind > b[0].chapter.ind
						})
						//self.dat = self.dat.reverse()
					}
					if (!self.data || self.data === '') {
						//self.dat.forEach(function(data))
						if (self.dat[0] && self.dat[0][0].chapter.ind === self.dat[self.dat.length - 1][0].chapter.ind) {
							self.data = self.dat[0]
						} else {
							if (self.dat[0]) {
								self.data = [].concat.apply([], self.dat);
							}
						}
						if (!self.doc || self.doc === '') {
							
						} else {
							
							self.edit = self.doc.index;
							self.dindexes = [self.edit];
							self.dindex = 0;
						}
					}

					setTimeout(function(){
						if (!self.tinymce && $('#description')[0] && tinymce) {
							self.tinymce = tinymce.init({
								menubar: false,
								statusbar: false,
								theme: 'inlite',
								inline: true,
								selector: "#description",
								plugins: 'table',
								selectiion_toolbar: 'undo redo | bold italic underline strikethrough | alignleft aligncenter alignright alignjustify alignnone | outdent indent blockquote | subscript superscript | bullist numlist | link unlink | table',
								table_toolbar: "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"

							});

						}
					}, 500);
					
					self.loadMap(function(map, dataLayer){
						if (!map) return;
						self.map = map;
						self.dataLayer = dataLayer;
						self.lMarker.on('dragend', function(event){
							var marker = event.target;
							var position = event.target.getLatLng();
							var lat = position.lat;
							var lng = position.lng;
							self.lMarker.setLatLng(new L.LatLng(position.lat, position.lng),{draggable:'true'});
							self.map.panTo(new L.LatLng(position.lat, position.lng))
							self.position.lng = lng;
							self.position.lat = lat;
							self.doc.geometry.coordinates = [lng, lat];
							console.log(self.doc.geometry.coordinates)
						})
						self.dataLayer.on('click', function(event) {
							//$('.module').removeClass('full');
							latlng = event.latlng;

							width = self.wWidth;
							height = self.wHeight;
							pWidth = 0.5 * width;
							pHeight = 0.5 * height;

							zoom = map.getZoom();
							var latlng = event.latlng;
							var dx = map.latLngToLayerPoint(latlng).x;
							var dy = map.latLngToLayerPoint(latlng).y;
							
							self.coincidentVectors(dx, dy, function(ret){
								if (ret) {
									console.log(ret)
									console.log('coincidences')
									// coincidents
									list = ret;
								} else {
									// single click
								}
								
							});
							
						});
						self.panZoom();
						
					})
				},
				beforeDestroy: function(){
					
				},
				methods: {
					featureImg: function(ind){
						var self = this;
						var index = parseInt(ind, 10);
						console.log(self.doc.properties.media[index].featured)
						self.doc.properties.media[index].featured = !self.doc.properties.media[index].featured;
					},
					checkChapterName: function() {
						var self = this;
						$.post('/checkchaptername/'+$('#chaptername').val()+'', function(res){
							if (!res) {
								self.uploadisreplace = false;
							} else {
								$('#info').html('<p class="danger">You will be replacing an existing chapter.</p>')
								self.uploadisreplace = true;
								self.uploadchtitle = res;
							}
							$('#importarea').show();
						})
					},
					navigateTo: function(url){
						window.location.href = url;
					},
					deleteEntry: function(doc) {
						$.post('/api/deleteentry/'+doc._id+'/'+doc.index+'', function(res){
							window.location.href = '/menu/'+doc.title.ind+'/'+doc.chapter.ind+'';
						})
					},
					deleteMedia: function(ind) {
						var self = this;
						$.post('/api/deletemedia/'+self.doc._id+'/'+ind+'', function(res){
							self.doc = res;
						})
					},
					accordion: function(n, ind) {
						var self = this;
						//console.log(self.accordions[n])
						if (self.accordions[n].indexOf(ind) === -1) {
							self.accordions[n].push(ind);
							self.accordions[n].sort();
						} else {
							self.accordions[n].splice(self.accordions[n].indexOf(ind), 1);
						}
					},
					parseBool: function(item) {
						if (!item) return false;
						return true;
					},
					toggleExport: function() {
						this.export = !this.export;
					},
					getHTML: function(type, str) {
						var self = this;
						var span = document.createElement(type);
						span.innerHTML = str;
						return span.outerHTML;
					},
					computeDiffStr: function(diffs) {
						diffs.forEach(function(diff) {
							return diff
						})
					},
					getDiffHtml: function() {
						var self = this;
						sendDiff(function(diffs){
							return ('<test></test>')
						})
					},
					sendDiff: function(cb) {
						var self = this;
						var fd = new FormData();
						var innerhtmldiv = $('div.centerallwrap')[0];
						if (!innerhtmldiv) return;
						var innerhtml = $(innerhtmldiv).html().toString();
						fd.append("str", innerhtml);
						
						var uploadurl = '/diff';
						$.ajax({
							url: uploadurl,
							type: 'POST',
							data: fd,
							processData: false,
							contentType: false,
							success: function(diff) { 
								cb(diff)
								console.log(self.diff)
							}
							
						})
					},
					dPathAttr: function() {
						var self = this;
						var thickness = (!thickness ? 45 : thickness);
						var nw = (!self.wWidth ? window.innerWidth : self.wWidth);
						var nh = (!self.wHeight ? window.innerHeight : self.wHeight);
						
						var d = "M0,0v"+nh+"h"+nw+"V0H0L0,0z "+
						"M"+(thickness)+","+(thickness)+"H"+(nw - thickness)+"V"+(nh - thickness)+"H"+(thickness)+"V"+(thickness)+"z "
						return d;
					},
					widthRectAttr: function(plus,type){
						var nw = this.getSize(type).nw;
						return nw - ((self.thickness + plus) * 2);
					},
					heightRectAttr: function(plus,type){
						var nh = this.getSize(type).nh;
						return nh - ((self.thickness + plus) * 2);
					},
					panZoom: function(){
						var self = this;
						$.post('/panzoom/'+self.map.getCenter().lat+'/'+self.map.getCenter().lng+'/'+self.map.getZoom()+'', function(result){
						})
					},
					importTxt: function(e){
						var self = this;
						var file = document.getElementById('importtxt').files[0];//e.target.files[0];
						var reader = new FileReader();
						
						reader.onloadend = function(e) {
							var fd = new FormData();

							fd.append("txt", file);
							var chtitle = encodeURIComponent($('#chaptername').val());
							var uploadurl = '/api/importtxt/txt/'+(self.uploadchtitle ? self.uploadchtitle : chtitle )+'/'+self.uploadisreplace+'';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
								success: function(response) { 
									window.location.href = '/'
								}
								
							})
						}
						reader.readAsDataURL(file)
					},
					importCsv: function(e){

						var self = this;
						var file = document.getElementById('importcsv').files[0];//e.target.files[0];
						var reader = new FileReader();
						
						reader.onloadend = function(e) {
							var fd = new FormData();

							fd.append("csv", file);
							
							var uploadurl = '/api/importcsv/'+(!self.doc || self.doc === '' ? self.data[self.dindex]._id : self.doc._id )+'/csv';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
								success: function(response) { 
									self.doc = response;
									var bounds = self.dataLayer.getBounds();
									self.map.fitBounds(bounds);
								}
								
							})
						}
						reader.readAsDataURL(file)
						
					},
					submitForm: function(ind){
						$('#form_'+ind+'').submit()
					},
					parseObj: function(obj) {
						if (!obj) return '';
						return obj;
					},
					toggleEdit: function(ind) {
						var self = this;
						this.edit = (!this.edit ? ind : null);
						
						
						
					},
					addMapBlob: function() {
						var self = this;
						var ind = self.doc.properties.media.length;
						self.addNewMedia(self.doc._id, ind, function(){
							//var canvas = document.querySelector('canvas.leaflet-zoom-animated');
							leafletImage(self.map, function(err, canvas){
								if (err) {
									return console.log(err)
								}
								setTimeout(function(){
									var img = document.querySelector('img#return'+ind+'');
									self.uploadBlob(img, canvas, ind, function(){

									})
								},2000)
							})
							
							
							
						});
						
					},
					addNewMedia: function(id, index, cb) {
						var self = this;
						$.post('/api/newmedia/'+id+'/'+index+'', function(res) {
							self.doc.properties.media.push(res)
							cb()
						})
					},
					handleFile: function(dindex, index) {
						var self = this;
						self.dindex = dindex;
						self.file = document.getElementById('media_'+index).files[0];
						self.processImage(index);
					},
					processImage: function(imgindex) {
						var self = this;
						var dataurl = null;
						var file = self.file;
						if (!file) return;
						var imagefile = file.type;
						var imageTypes= ["image/jpeg","image/png","image/jpg","image/svg+xml"];
						if(imageTypes.indexOf(imagefile) === -1) {
							$("#info").html("<span class='msg-error'>Please Select A valid Image File</span><br /><span>Only jpeg, jpg, png, and pdf types allowed</span>");
							return false;
							
						} else {
							var reader = new FileReader();
							
							reader.onloadend = function(e) {
								var img = document.getElementById('return'+imgindex+'');
								img.src = e.target.result;
								var type = imagefile.split('image/')[1];
								img.onload = function() {
									$('#media').val('');
									var can = $('#canvas'+imgindex+'')[0];
									var maxWidth = 1700 ;
									var maxHeight = 1700 ;
									var w = img.width;
									var h = img.height;
									can.width = w;
									can.height = h;
									var ctx = can.getContext("2d");
									ctx.drawImage(img, 0, 0);
									self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, type);
								}
								
							}
							reader.readAsDataURL(file);
						}
					},
					checkImage: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype) {
						var self = this;
						if (h > maxHeight) {
							self.reSize(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
						} else {
							if (maxHeight === 400) {
								self.drawThumb(img, can, w, h, imgindex, imgtype)
							} else {
								self.drawFull(img, can, w, h, imgindex, imgtype)
							}
						}
						
					},
					reSize: function(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype){
						can.height = h*0.75;
						can.width = w*0.75;

						var can2 = document.createElement('canvas');
						can2.width = w*0.75;
						can2.height = h*0.75;
						var ctx2 = can2.getContext('2d');
						var ctx = can.getContext('2d');
						ctx2.drawImage(img, 0, 0, w*0.75, h*0.75);
						ctx.drawImage(can2, 0, 0, w*0.75, h*0.75, 0, 0, w*0.75, h*0.75);
						w = w*0.75;
						h = h*0.75;
						img.width = w;
						img.height = h;
						this.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype)
					},
					uploadBlob: function(img, can, imgindex, cb) {
						var self = this;
						if (!HTMLCanvasElement.prototype.toBlob) {
						 Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', {
							value: function (callback, type, quality) {
								var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),
								len = binStr.length,
								arr = new Uint8Array(len);
								for (var i = 0; i < len; i++ ) {
									arr[i] = binStr.charCodeAt(i);
								}
								callback( new Blob( [arr], {type: type || 'image/png'} ) );
							}
						 });
						}
						can.toBlob(function(blob) {
							var fd = new FormData();
							fd.append("img", blob);
							var uploadurl = '/api/uploadmedia/'+self.doc.index+'/'+imgindex+'/png';
							$.ajax({
								url: uploadurl,
								type: 'POST',
								data: fd,
								processData: false,
								contentType: false,
									success: function(response) { 
									img.src = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
									img.onload = function () {
										self.doc.properties.media[imgindex].image_abs = response;
										self.doc.properties.media[imgindex].image = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										self.doc.properties.media[imgindex].thumb_abs = response;
										self.doc.properties.media[imgindex].thumb = response.replace('/var/www/pu', '').replace('/Users/traceybushman/Documents/pu.bli.sh/pu', '');
										cb();
									}
								}
							})
						}, 'image/png');
					},
					drawFull: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
						
						ctx.drawImage(img, 0, 0, w, h);
						self.uploadBlob(img, can, imgindex, function(){
							var can = $('#canvas'+imgindex+'')[0];
							var maxWidth = 400 ;
							var maxHeight = 400 ;
							var w = img.width;
							var h = img.height;

							self.checkImage(img, can, w, h, maxWidth, maxHeight, imgindex, imgtype);
						})
						
					},
					drawThumb: function(img, can, w, h, imgindex, imgtype) {
						var self = this;
						can.height = h;
						can.width = w;
						var ctx = can.getContext('2d');
						
						ctx.drawImage(img, 0, 0, w, h);
						var dataurl = can.toDataURL("image/png", 0.8);
						setTimeout(function(){
							self.doc.properties.media[imgindex].thumb = dataurl;
							//$('#inputthumb'+imgindex+'').val(dataurl.replace(/data:image\/png;base64,/, ''));
							
						}, 100);
					},
					loadMap: function(cb) {
						var self = this;
						var dataLayer;
						var dataCoords;
						var map = new L.map('map', { 
							center: [
								(!self.position ? 41.509859 : self.position.lat),
								(!self.position ? -112.015802 : self.position.lng)
							], 
							zoom: (!self.position ? 6 : self.position.zoom),
							zoomControl: false,
							minZoom: 2,
							maxZoom: 18,
							renderer: L.canvas(),
							preferCanvas: true
						});
						if (self.infowindow === 'tooltip') {
							L.control.zoom({
								position:'bottomleft'
							}).addTo(map);
						} else {
							L.control.zoom({
								position:'topleft'
							}).addTo(map);
						}
						
						var options3 = {
							
							attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
						};
						//https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png
						//L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', options3).addTo(map);
						//var canvas = L.tileLayer.canvas();
						//canvas.drawTile = function(can, )
						L.tileLayer('https://api.mapbox.com/styles/v1/tbushman/ciq7gm0ov008kbfm580v9mm9c/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoidGJ1c2htYW4iLCJhIjoiSmI0aU94OCJ9.SZytljBzoWupPUYeu_OR9A', {renderer: L.canvas({padding:0.5}), bounds: map.getBounds().pad(100)}).addTo(map);
						//var tileCanvas = L.tileLayer.canvas('https://api.mapbox.com/styles/v1/tbushman/ciq7gm0ov008kbfm580v9mm9c/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoidGJ1c2htYW4iLCJhIjoiSmI0aU94OCJ9.SZytljBzoWupPUYeu_OR9A', {renderer: L.canvas({padding:0.5}), bounds: map.getBounds().pad(100)})//.addTo(map); //slc transit
						//tileCanvas.drawTile = function()
						//var stamenLayer = new L.StamenTileLayer('terrain');
						//map.addLayer(stamenLayer)
						//L.tileLayer('http://{s}.tiles.mapbox.com/v3/tbushman.iba1gl27/{z}/{x}/{y}.png').addTo(map);
						
						//L.tileLayer('http://tile.thunderforest.com/outdoors/${z}/${x}/${y}.png').addTo(map);
						if (!self.dataLayer && self.doc) {
							// generate geographic points from data
							if (self.doc && self.doc !== '') {
								var myRenderer = L.canvas({ padding: 0.5 });
								//dataLayer = L.GeoJSON.geometryToLayer(self.doc).addTo(map);
								dataLayer = L.geoJSON([self.doc], {
									// MongoDB stores coordinates as [lng, lat]
									// Leaflet uses [lat, lng]
									onEachFeature: function (feature) {
										if (feature.geometry.type === 'Point') {
										}
										
									},
									geometryToLayer: function(feature) {
										if (feature.geometry.type === 'LineString') {
											//console.log(feature.geometry.type )
											var geojsonPolygonOptions = {
												fillColor: 'var(--highlight)',
												color: '#fff',
												weight: 2,
												opacity: 1,
												fillOpacity: 0.8,
												className: feature._id+'@'+feature.authorname+''
											};
											var polygon = L.polygon(feature.geometry.coordinates, geojsonPolygonOptions);
											return polygon;
										}
									},
									pointToLayer: function (feature, latlng) {
										if (feature.geometry.type === 'Point') {
											//console.log(feature)
											var geojsonMarkerOptions = {
												radius: 11,
												fillColor: 'var(--highlight)',
												color: '#fff',
												weight: 2,
												opacity: 1,
												fillOpacity: 0.8,
												className: feature._id+'@'+feature.authorname+'@'+map.latLngToLayerPoint(latlng).x+','+map.latLngToLayerPoint(latlng).y+''
											};
											var circleMarker = L.circleMarker(latlng, geojsonMarkerOptions);
											return circleMarker;
										}
										
									}
								}).addTo(map);
								dataCoords = self.doc.geometry.coordinates;
							}
							self.lMarker = L.marker([dataCoords[1], dataCoords[0]], {draggable: true}).addTo(map);
							//map.panTo(new L.LatLng(dataCoords[1], dataCoords[0]));
							var bounds = dataLayer.getBounds();
							map.fitBounds(bounds);
							cb(map, dataLayer)

						} else {
							cb(null)
							console.log('when?')
						}
					},
					coincidentVectors: function(dx, dy, cb) {
						var self = this;
						
						var point = L.point(dx,dy);
						var vector = self.dataLayer.closestLayerPoint(point);
						var position = self.map.layerPointToLatLng(vector);
						self.map.panTo(position);
						var ind;
						self.doc.geometry.coordinates.forEach(function(coord, i){
							if (coord[0] === position.lat && coord[1] === position.lng) {
								ind = i;
							} 
						})
						self.lMarker.setLatLng(new L.LatLng(position.lat, position.lng),{draggable:'true'});
					}
				}
			});
	